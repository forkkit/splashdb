"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t=e(require("http2")),i=e(require("crypto")),s=e(require("path")),r=e(require("assert")),n=e(require("buffer")),o=e(require("fs")),a=e(require("os")),l=e(require("events"));function u(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class f{constructor(e,t){u(this,"options",void 0),u(this,"dbmanager",void 0),this.options=e,this.dbmanager=t}async can(e,t,i){return!!e}}function h(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function c(e,t,i){return e(i={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==t&&i.path)}},i.exports),i.exports}var d=function e(t,i,s){i=i||[];var r=s=s||0;for(;t>=p;)i[s++]=255&t|128,t/=128;for(;-128&t;)i[s++]=255&t|128,t>>>=7;return i[s]=0|t,e.bytes=s-r+1,i},p=Math.pow(2,31);var m=function e(t,i){var s,r=0,n=0,o=i=i||0,a=t.length;do{if(o>=a)throw e.bytes=0,new RangeError("Could not decode varint");s=t[o++],r+=n<28?(127&s)<<n:(127&s)*Math.pow(2,n),n+=7}while(s>=128);return e.bytes=o-i,r};var b=Math.pow(2,7),g=Math.pow(2,14),_=Math.pow(2,21),y=Math.pow(2,28),v=Math.pow(2,35),w=Math.pow(2,42),k=Math.pow(2,49),S=Math.pow(2,56),B=Math.pow(2,63),F={encode:d,decode:m,encodingLength:function(e){return e<b?1:e<g?2:e<_?3:e<y?4:e<v?5:e<w?6:e<k?7:e<S?8:e<B?9:10}},L=c((function(e,t){t.__esModule=!0,t.default=void 0;class i{constructor(e=Buffer.alloc(0)){!function(e,t,i){t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i}(this,"_buffer",void 0),e instanceof i?this._buffer=e._buffer:Buffer.isBuffer(e)?this._buffer=e:this._buffer="string"==typeof e?Buffer.from(e):Buffer.from(JSON.stringify(e))}get buffer(){return this._buffer}set buffer(e){this._buffer=e}get length(){return this._buffer.length}get size(){return this._buffer.length}toString(e){return this._buffer.toString(e)}clear(){this._buffer=Buffer.alloc(0)}compare(e){return this._buffer.compare(e.buffer)}isEqual(e){return 0===this.compare(e)}}t.default=i})),x=c((function(e,t){t.__esModule=!0,t.encodeFixed64=function(e){const t=Buffer.alloc(8),i=BigInt(e);return t.writeBigUInt64LE(i<a?i:a),t},t.decodeFixed64=function(e){const t=e.readBigUInt64LE();return Number(t)},t.encodeFixed32=function(e){const t=Buffer.alloc(4);return t.writeUInt32LE(e,0),t},t.decodeFixed32=function(e){return(0,n.default)(e.length>=4),e.readUInt32LE(0)},t.getLengthPrefixedSlice=function(e){const t=i.default.decode(e.buffer),r=e.buffer.slice(i.default.decode.bytes,i.default.decode.bytes+t);return new s.default(r)};var i=o(F),s=o(L),n=o(r);function o(e){return e&&e.__esModule?e:{default:e}}const a=(1n<<56n)-1n})),C=c((function(e,t){t.__esModule=!0,t.extractUserKey=g,t.parseInternalKey=function(e,t){try{t.userKey=g(e);const i=Buffer.alloc(8);return i.fill(e.buffer.slice(e.length-8),0,7),t.sn=new b((0,x.decodeFixed64)(i)),t.valueType=e.buffer[e.length-1],!0}catch(e){return!1}},t.BlockHandle=t.LookupKey=t.InternalKeyComparator=t.kSizeOfUInt32=t.Config=t.kBlockTrailerSize=t.InternalKeyBuilder=t.InternalKey=t.SequenceNumber=t.CompressionTypes=t.VersionEditTag=t.ParsedInternalKey=t.kMaxSequenceNumber=t.kValueTypeForSeek=t.ValueType=t.FileType=void 0;var i=o(r),s=o(F),n=o(L);function o(e){return e&&e.__esModule?e:{default:e}}function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}let l,u;t.FileType=l,function(e){e[e.kLogFile=0]="kLogFile",e[e.kDBLockFile=1]="kDBLockFile",e[e.kTableFile=2]="kTableFile",e[e.kDescriptorFile=3]="kDescriptorFile",e[e.kCurrentFile=4]="kCurrentFile",e[e.kTempFile=5]="kTempFile",e[e.kInfoLogFile=6]="kInfoLogFile"}(l||(t.FileType=l={})),t.ValueType=u,function(e){e[e.kTypeDeletion=0]="kTypeDeletion",e[e.kTypeValue=1]="kTypeValue"}(u||(t.ValueType=u={}));const f=u.kTypeValue;t.kValueTypeForSeek=f;const h=(1n<<56n)-1n;t.kMaxSequenceNumber=h;class c{constructor(e,t,i){a(this,"userKey",void 0),a(this,"sn",void 0),a(this,"valueType",void 0),void 0!==e&&void 0!==t&&void 0!==i&&(this.userKey=e,this.sn=t,this.valueType=i)}}function d(e,t){const s=BigInt(e);return(0,i.default)(s<=h),(0,i.default)(t<=f),s<<8n|BigInt(t)}let p,m;t.ParsedInternalKey=c,t.VersionEditTag=p,function(e){e[e.kComparator=1]="kComparator",e[e.kLogNumber=2]="kLogNumber",e[e.kNextFileNumber=3]="kNextFileNumber",e[e.kLastSequence=4]="kLastSequence",e[e.kCompactPointer=5]="kCompactPointer",e[e.kDeletedFile=6]="kDeletedFile",e[e.kNewFile=7]="kNewFile",e[e.kPrevLogNumber=9]="kPrevLogNumber"}(p||(t.VersionEditTag=p={})),t.CompressionTypes=m,function(e){e[e.none=0]="none"}(m||(t.CompressionTypes=m={}));class b{constructor(e=0){a(this,"_value",void 0),a(this,"toFixed64Buffer",()=>(0,x.encodeFixed64)(this._value)),this._value=e}get value(){return this._value}set value(e){this._value=e}toBuffer(){return Buffer.from(s.default.encode(this._value))}}function g(e){return(0,i.default)(e.size>=8),new n.default(e.buffer.slice(0,e.size-8))}t.SequenceNumber=b;class _ extends n.default{static from(e){const t=new _;return(0,i.default)(t.decodeFrom(e)),t}constructor(e,t,i){super(),void 0!==e&&void 0!==t&&void 0!==i&&(this.buffer=function(e,t){const i=t.sn.toFixed64Buffer();return i.fill(t.valueType,7,8),Buffer.concat([e,t.userKey.buffer,i])}(this.buffer,new c(e,t,i)))}get userKey(){return g(this)}get type(){return this.buffer[this.buffer.length-1]}get sequence(){const e=Buffer.alloc(8);return e.fill(this.buffer.slice(this.buffer.length-8),0,7),(0,x.decodeFixed32)(e)}decodeFrom(e){return this.buffer=e.buffer,this.buffer.length>0}}t.InternalKey=_,a(_,"kMaxSequenceNumber",new b(72057594037927940));t.InternalKeyBuilder=class{build(e,t,i){const s=e.toFixed64Buffer();s.fill(t,7,8);const r=new n.default(Buffer.concat([i.buffer,s]));return new _(r)}};t.kBlockTrailerSize=5;class y{}t.Config=y,a(y,"kNumLevels",7),a(y,"kL0CompactionTrigger",4),a(y,"kL0SlowdownWritesTrigger",8),a(y,"kL0StopWritesTrigger",12),a(y,"kMaxMemCompactLevel",2),a(y,"kReadBytesPeriod",1048576);t.kSizeOfUInt32=4;t.InternalKeyComparator=class{constructor(e){a(this,"_userComparator",void 0),a(this,"oneByte",Buffer.alloc(1)),this._userComparator=e}get userComparator(){return this._userComparator}getName(){return"leveldb.InternalKeyComparator"}findShortestSeparator(e,t){const s=g(e),r=g(t),o=new n.default(Buffer.from(s.buffer));this.userComparator.findShortestSeparator(o,r),o.size<s.size&&this.userComparator.compare(s,o)<0&&(o.buffer=Buffer.concat([o.buffer,(0,x.encodeFixed64)(d(h,f))]),(0,i.default)(this.compare(e,o)<0),(0,i.default)(this.compare(o,t)<0),e.buffer=o.buffer)}findShortSuccessor(e){const t=g(e),s=new n.default(Buffer.from(t.buffer));this._userComparator.findShortSuccessor(s),s.size<t.size&&this._userComparator.compare(t,s)<0&&(s.buffer=Buffer.concat([s.buffer,(0,x.encodeFixed64)(d(h,f))]),(0,i.default)(this.compare(e,s)<0),e.buffer=s.buffer)}compare(e,t){const i=g(e),s=g(t),r=this.userComparator.compare(i,s);if(0!==r)return r;const n=(0,x.decodeFixed64)(Buffer.concat([e.buffer.slice(e.size-8,e.size-1),this.oneByte])),o=(0,x.decodeFixed64)(Buffer.concat([t.buffer.slice(t.size-8,t.size-1),this.oneByte]));return n===o?0:n>o?-1:1}};t.LookupKey=class{constructor(e,t){a(this,"_internalKeySizeBuf",void 0),a(this,"_userKeyBuf",void 0),a(this,"_sequenceBuf",void 0),this._userKeyBuf=e.buffer,this._internalKeySizeBuf=Buffer.from(s.default.encode(e.size+8)),this._sequenceBuf=t.toFixed64Buffer(),this._sequenceBuf.fill(Buffer.from(s.default.encode(f)),7)}get buffer(){return Buffer.concat([this._internalKeySizeBuf,this._userKeyBuf,this._sequenceBuf])}get internalKey(){return new n.default(Buffer.concat([this._userKeyBuf,this._sequenceBuf]))}get memKey(){return new n.default(this.buffer)}get userKey(){return new n.default(this._userKeyBuf)}set userKey(e){this._userKeyBuf=e.buffer,this._internalKeySizeBuf=Buffer.from(s.default.encode(e.size+8))}};class v{constructor(){a(this,"offset",void 0),a(this,"size",void 0)}static from(e){const t=new v;return t.offset=s.default.decode(e),t.size=s.default.decode(e,s.default.decode.bytes),t}get buffer(){return(0,i.default)("number"==typeof this.offset),(0,i.default)("number"==typeof this.size),Buffer.concat([Buffer.from(s.default.encode(this.offset)),Buffer.from(s.default.encode(this.size))])}}t.BlockHandle=v})),N=c((function(e,t){function i(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.__esModule=!0,t.default=void 0;t.default=class{constructor(e,t,s){i(this,"key",void 0),i(this,"maxlevel",void 0),i(this,"levels",void 0),this.key=t,this.maxlevel=e,this.levels=new Array(e+1),s&&this.fill(s)}fill(e){for(let t=0;t<=this.maxlevel;t++)this.levels[t]=e}next(e){return this.levels[e]}}})),I=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=o(r),s=o(L),n=o(N);function o(e){return e&&e.__esModule?e:{default:e}}function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}const l=1/Math.E;t.default=class{constructor(e,t=65535){a(this,"keyComparator",void 0),a(this,"maxsize",void 0),a(this,"level",void 0),a(this,"head",void 0),this.maxsize=t,this.level=0,this.keyComparator=e,this.head=new n.default(12,new s.default)}isKeyAfterNode(e,t){return!!t&&this.keyComparator(t.key,e)<0}generateNodeLevel(){let e=1;const t=Math.min(12,this.level+1);for(;Math.random()<l&&e<t;)e++;return(0,i.default)(e>0),(0,i.default)(e<=12),e}findGreaterOrEqual(e,t){let i=12,s=this.head;for(;;){const r=s.next(i);if(this.isKeyAfterNode(e,r))s=r;else{if(t&&(t[i]=s),0===i)return r;i--}}}*iterator(){let e=this.head;for(;e&&e.next(0);)yield e.next(0).key,e=e.next(0)}isEqual(e,t){return e.isEqual(t)}seek(e){return this.findGreaterOrEqual(e)}put(e){const t=new Array(12),s=this.findGreaterOrEqual(e,t);(0,i.default)(!s||!this.isEqual(e,s.key));const r=this.generateNodeLevel();if(r>this.level){for(let e=this.level;e<r;e++)t[e]=this.head;this.level=r}const o=new n.default(r,e);for(let e=0;e<r;e++)t[e]&&(o.levels[e]=t[e].levels[e],t[e].levels[e]=o)}}})),T=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=a(r),s=a(F),n=a(I),o=a(L);function a(e){return e&&e.__esModule?e:{default:e}}function l(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class u{static getValueSlice(e){const t=s.default.decode(e.buffer);if(s.default.decode(e.buffer.slice(t))===C.ValueType.kTypeDeletion)return null;const i=e.buffer.slice(s.default.decode.bytes+t),r=s.default.decode(i),n=i.slice(s.default.decode.bytes,s.default.decode.bytes+r);return new o.default(n)}static getEntryFromMemTableKey(e){let t=0;const i=s.default.decode(e.buffer);t+=s.default.decode.bytes;const r=new o.default(e.buffer.slice(t,t+i));t+=i;const n=s.default.decode(e.buffer.slice(t));t+=s.default.decode.bytes;return{key:r,value:new o.default(e.buffer.slice(t,t+n))}}constructor(e){l(this,"_immutable",void 0),l(this,"_list",void 0),l(this,"_size",void 0),l(this,"refs",void 0),l(this,"internalKeyComparator",void 0),l(this,"keyComparator",(e,t)=>{const i=(0,x.getLengthPrefixedSlice)(e),s=(0,x.getLengthPrefixedSlice)(t);return this.internalKeyComparator.compare(i,s)}),this._immutable=!1,this.internalKeyComparator=e,this._list=new n.default(this.keyComparator),this._size=0,this.refs=0}ref(){this.refs++}unref(){this.refs--}get size(){return this._size}get immutable(){return this._immutable}set immutable(e){e&&(this._immutable=!0)}add(e,t,r,n){const a=r.length,l=n?n.length:0,u=a+8,f=Buffer.from(s.default.encode(l));let h=u+l+s.default.encode.bytes;const c=Buffer.from(s.default.encode(u));h+=s.default.encode.bytes;const d=e.toFixed64Buffer();d.fill(t,7,8);const p=new o.default(Buffer.concat([c,r.buffer,d,f,n?n.buffer:Buffer.alloc(0)]));(0,i.default)(h===p.length,"Incorrect length"),this._list.put(p),this._size+=p.length}get(e){const t=e.memKey,i=this._list.seek(t);if(i){const t=u.getEntryFromMemTableKey(i.key),s=C.InternalKey.from(t.key);if(0===this.internalKeyComparator.userComparator.compare(s.userKey,e.userKey))return{key:t.key,value:t.value,type:s.type}}}*iterator(){for(const e of this._list.iterator())yield u.getEntryFromMemTableKey(e)}}t.default=u})),K=n.Buffer,z=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];function M(e){if(K.isBuffer(e))return e;var t="function"==typeof K.alloc&&"function"==typeof K.from;if("number"==typeof e)return t?K.alloc(e):new K(e);if("string"==typeof e)return t?K.from(e):new K(e);throw new Error("input must be buffer, number, or string, received "+typeof e)}function O(e){var t=M(4);return t.writeInt32BE(e,0),t}function E(e,t){e=M(e),K.isBuffer(t)&&(t=t.readUInt32BE(0));for(var i=-1^~~t,s=0;s<e.length;s++)i=z[255&(i^e[s])]^i>>>8;return-1^i}function P(){return O(E.apply(null,arguments))}"undefined"!=typeof Int32Array&&(z=new Int32Array(z)),P.signed=function(){return E.apply(null,arguments)},P.unsigned=function(){return E.apply(null,arguments)>>>0};var R=P,V=c((function(e,t){let i;t.__esModule=!0,t.createHexStringFromDecimal=function(e){let t=e.toString(16);for(;t.length<4;)t="0"+t;return t},t.kHeaderSize=t.kBlockSize=t.kMaxRecordType=t.RecordType=void 0,t.RecordType=i,function(e){e[e.kZeroType=0]="kZeroType",e[e.kFullType=1]="kFullType",e[e.kFirstType=2]="kFirstType",e[e.kMiddleType=3]="kMiddleType",e[e.kLastType=4]="kLastType"}(i||(t.RecordType=i={}));const s=i.kLastType;t.kMaxRecordType=s;t.kBlockSize=32768;t.kHeaderSize=7})),q=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=n(r),s=n(R);function n(e){return e&&e.__esModule?e:{default:e}}function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.default=class{constructor(e){o(this,"_file",void 0),o(this,"_blockOffset",void 0),o(this,"close",async()=>{(0,i.default)(!!this._file);const e=this._file;delete this._file;try{await e.close()}catch(e){}}),o(this,"emitPhysicalRecord",async(e,t)=>{const i=Buffer.alloc(V.kHeaderSize),r=e.length;i[4]=255&r,i[5]=r>>8,i[6]=t;const n=(0,s.default)(Buffer.concat([Buffer.from([t]),e,Buffer.from([e.length])]));i.fill(n,0,4),this._blockOffset+=e.length+V.kHeaderSize,await this.appendFile(Buffer.concat([i,e]))}),o(this,"addRecord",async e=>{let t=!1,s=e.size,r=0;for(;s>0;){const n=V.kBlockSize-this._blockOffset;(0,i.default)(n>=0),n<V.kHeaderSize&&(n>0&&((0,i.default)(7==V.kHeaderSize),await this.appendFile(Buffer.alloc(n))),this._blockOffset=0),(0,i.default)(V.kBlockSize-this._blockOffset-V.kHeaderSize>=0);const o=V.kBlockSize-this._blockOffset-V.kHeaderSize,a=s<o?s:o;let l;const u=s===a;l=!t&&u?V.RecordType.kFullType:t?u?V.RecordType.kLastType:V.RecordType.kMiddleType:V.RecordType.kFirstType,await this.emitPhysicalRecord(e.buffer.slice(r,r+a),l),t=!0,r+=a,s-=a}}),this._blockOffset=0,this._file=e}async appendFile(e){await this._file.appendFile(e,{})}}})),D=c((function(e,t){t.__esModule=!0,t.BytewiseComparator=void 0;var i,s=(i=r)&&i.__esModule?i:{default:i};t.BytewiseComparator=class{getName(){return"leveldb.BytewiseComparator"}compare(e,t){return e.compare(t)}findShortestSeparator(e,t){const i=Math.min(e.length,t.size);let r=0;for(;r<i&&e.buffer[r]==t.buffer[r];)r++;if(r>=i);else{const i=e.buffer[r];i<255&&i+1<t.buffer[r]&&(e.buffer[r]++,e.buffer=e.buffer.slice(0,r+1),(0,s.default)(this.compare(e,t)<0))}}findShortSuccessor(e){const t=e.length;for(let i=0;i<t;i++){const t=e.buffer[i];if(255!=t)return e.buffer[i]=t+1,void(e.buffer=e.buffer.slice(0,i+1))}}}})),U=c((function(e,t){function i(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.__esModule=!0,t.default=void 0;t.default=class{constructor(e){i(this,"_size",void 0),i(this,"_buffer",void 0),this._buffer=e,this._size=e.length}get buffer(){return this._buffer}get size(){return this._size}get bits(){return 8*this.size}resizeBits(e){const t=Math.ceil(e/8);t>this.size?(this._buffer=Buffer.concat([this._buffer,Buffer.alloc(t-this.size)]),this._size=this._buffer.length):t<this.size&&(this._buffer=this._buffer.slice(0,t),this._size=this._buffer.length)}set(e,t){const i=e>>>3;t?this._buffer[i]|=1<<e%8:this._buffer[i]&=~(1<<e%8)}toggle(e){this._buffer[e>>>3]^=1<<e%8}get(e){return 0!=(this._buffer[e>>>3]&1<<e%8)}toString(){let e="";for(let t=0;t<this.bits;t++)e+=this.get(t)?"1":"0";return e}}})),A=c((function(e,t){function i(e,t){return e.charCodeAt(t++)+(e.charCodeAt(t++)<<8)+(e.charCodeAt(t++)<<16)+(e.charCodeAt(t)<<24)}function s(e,t){return e.charCodeAt(t++)+(e.charCodeAt(t++)<<8)}function r(e,t){return(65535&(e|=0))*(t|=0)+(((e>>>16)*t&65535)<<16)|0}t.__esModule=!0,t.default=function(e,t=0){const n=1540483477;let o=t^e.length,a=e.length,l=0;for(;a>=4;){let t=i(e,l);t=r(t,n),t^=t>>>24,t=r(t,n),o=r(o,n),o^=t,l+=4,a-=4}switch(a){case 3:o^=s(e,l),o^=e.charCodeAt(l+2)<<16,o=r(o,n);break;case 2:o^=s(e,l),o=r(o,n);break;case 1:o^=e.charCodeAt(l),o=r(o,n)}return o^=o>>>13,o=r(o,n),o^=o>>>15,o>>>0}})),W=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=n(F),s=n(U),r=n(A);function n(e){return e&&e.__esModule?e:{default:e}}function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class a{constructor(e,t=10){o(this,"_buffer",void 0),o(this,"_offset",void 0),o(this,"_size",void 0),o(this,"_kNumber",void 0),o(this,"_bitBuffer",void 0),o(this,"_bitsPerKey",void 0),this._offset=0,this._bitsPerKey=t;const r=Math.round(.69*t);e&&0!==e.length?(this._buffer=e,this._bitBuffer=new s.default(e.slice(0,e.length-1)),this._kNumber=i.default.decode(this._buffer.slice(this._buffer.length-1)),this._kNumber!==r&&(this._kNumber=r,this._buffer=Buffer.concat([this._buffer.slice(0,this._buffer.length-1),Buffer.from(i.default.encode(r))]),this._bitBuffer.resizeBits(r))):(this._buffer=Buffer.from(i.default.encode(r)),this._bitBuffer=new s.default(Buffer.alloc(Math.ceil(r/8))),this._kNumber=r),this._size=this._buffer.length}get bitsPerKey(){return this._bitsPerKey}get bitBuffer(){return this._bitBuffer}get buffer(){return this._buffer}get size(){return this._size}get kNumber(){return this._kNumber}name(){return"leveldb.BuiltinBloomFilter2"}putKeys(e,t){let i=this.bitsPerKey*t;i<64&&(i=64);i=8*((i+7)/8),this._bitBuffer.resizeBits(i),i=this._bitBuffer.bits;for(let s=0;s<t;s++){let t=(0,r.default)(e[s].toString());const n=t>>17|t<<15;for(let e=0;e<this.kNumber;e++){const e=t%i;this._bitBuffer.set(e,!0),t+=n}}this._buffer=Buffer.concat([this._bitBuffer.buffer,this._buffer.slice(this._offset+this._size-1,this._offset+this._size)]),this._size=this._buffer.length}keyMayMatch(e,t){const i=new a(t.buffer);if(i.kNumber>30)return!0;let s=(0,r.default)(e.toString());const n=s>>17|s<<15;for(let e=0;e<i.kNumber;e++){const e=s%i._bitBuffer.bits;if(!i._bitBuffer.get(e))return!1;s+=n}return!0}}t.default=a})),G=c((function(e,t){t.__esModule=!0,t.Log=function(e,t){if(e)return e.log(t);return Promise.resolve()},t.NodeEnv=t.InfoLog=void 0;var i=r(o),s=r(a);function r(e){return e&&e.__esModule?e:{default:e}}function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.InfoLog=class{constructor(e){n(this,"_file",void 0),this._file=e}async log(e){const t=`${(new Date).toISOString()} ${e}\n`;await this._file.appendFile(t)}};t.NodeEnv=class{constructor(){n(this,"writeFile",i.default.promises.writeFile),n(this,"readFile",i.default.promises.readFile),n(this,"open",i.default.promises.open),n(this,"rename",i.default.promises.rename),n(this,"unlink",i.default.promises.unlink),n(this,"unlinkSync",i.default.unlinkSync),n(this,"fstat",i.default.promises.fstat)}platform(){return s.default.platform()}now(){return Number(process.hrtime.bigint())/Math.pow(10,9)}access(e){return i.default.promises.access(e,i.default.constants.W_OK)}mkdir(e){return i.default.promises.mkdir(e,{recursive:!0})}readdir(e){return i.default.promises.readdir(e,{withFileTypes:!0})}}})),j=H;function H(e){var t=this;if(t instanceof H||(t=new H),t.tail=null,t.head=null,t.length=0,e&&"function"==typeof e.forEach)e.forEach((function(e){t.push(e)}));else if(arguments.length>0)for(var i=0,s=arguments.length;i<s;i++)t.push(arguments[i]);return t}function $(e,t,i){var s=t===e.head?new J(i,null,t,e):new J(i,t,t.next,e);return null===s.next&&(e.tail=s),null===s.prev&&(e.head=s),e.length++,s}function Q(e,t){e.tail=new J(t,e.tail,null,e),e.head||(e.head=e.tail),e.length++}function Z(e,t){e.head=new J(t,null,e.head,e),e.tail||(e.tail=e.head),e.length++}function J(e,t,i,s){if(!(this instanceof J))return new J(e,t,i,s);this.list=s,this.value=e,t?(t.next=this,this.prev=t):this.prev=null,i?(i.prev=this,this.next=i):this.next=null}H.Node=J,H.create=H,H.prototype.removeNode=function(e){if(e.list!==this)throw new Error("removing node which does not belong to this list");var t=e.next,i=e.prev;return t&&(t.prev=i),i&&(i.next=t),e===this.head&&(this.head=t),e===this.tail&&(this.tail=i),e.list.length--,e.next=null,e.prev=null,e.list=null,t},H.prototype.unshiftNode=function(e){if(e!==this.head){e.list&&e.list.removeNode(e);var t=this.head;e.list=this,e.next=t,t&&(t.prev=e),this.head=e,this.tail||(this.tail=e),this.length++}},H.prototype.pushNode=function(e){if(e!==this.tail){e.list&&e.list.removeNode(e);var t=this.tail;e.list=this,e.prev=t,t&&(t.next=e),this.tail=e,this.head||(this.head=e),this.length++}},H.prototype.push=function(){for(var e=0,t=arguments.length;e<t;e++)Q(this,arguments[e]);return this.length},H.prototype.unshift=function(){for(var e=0,t=arguments.length;e<t;e++)Z(this,arguments[e]);return this.length},H.prototype.pop=function(){if(this.tail){var e=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,e}},H.prototype.shift=function(){if(this.head){var e=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,e}},H.prototype.forEach=function(e,t){t=t||this;for(var i=this.head,s=0;null!==i;s++)e.call(t,i.value,s,this),i=i.next},H.prototype.forEachReverse=function(e,t){t=t||this;for(var i=this.tail,s=this.length-1;null!==i;s--)e.call(t,i.value,s,this),i=i.prev},H.prototype.get=function(e){for(var t=0,i=this.head;null!==i&&t<e;t++)i=i.next;if(t===e&&null!==i)return i.value},H.prototype.getReverse=function(e){for(var t=0,i=this.tail;null!==i&&t<e;t++)i=i.prev;if(t===e&&null!==i)return i.value},H.prototype.map=function(e,t){t=t||this;for(var i=new H,s=this.head;null!==s;)i.push(e.call(t,s.value,this)),s=s.next;return i},H.prototype.mapReverse=function(e,t){t=t||this;for(var i=new H,s=this.tail;null!==s;)i.push(e.call(t,s.value,this)),s=s.prev;return i},H.prototype.reduce=function(e,t){var i,s=this.head;if(arguments.length>1)i=t;else{if(!this.head)throw new TypeError("Reduce of empty list with no initial value");s=this.head.next,i=this.head.value}for(var r=0;null!==s;r++)i=e(i,s.value,r),s=s.next;return i},H.prototype.reduceReverse=function(e,t){var i,s=this.tail;if(arguments.length>1)i=t;else{if(!this.tail)throw new TypeError("Reduce of empty list with no initial value");s=this.tail.prev,i=this.tail.value}for(var r=this.length-1;null!==s;r--)i=e(i,s.value,r),s=s.prev;return i},H.prototype.toArray=function(){for(var e=new Array(this.length),t=0,i=this.head;null!==i;t++)e[t]=i.value,i=i.next;return e},H.prototype.toArrayReverse=function(){for(var e=new Array(this.length),t=0,i=this.tail;null!==i;t++)e[t]=i.value,i=i.prev;return e},H.prototype.slice=function(e,t){(t=t||this.length)<0&&(t+=this.length),(e=e||0)<0&&(e+=this.length);var i=new H;if(t<e||t<0)return i;e<0&&(e=0),t>this.length&&(t=this.length);for(var s=0,r=this.head;null!==r&&s<e;s++)r=r.next;for(;null!==r&&s<t;s++,r=r.next)i.push(r.value);return i},H.prototype.sliceReverse=function(e,t){(t=t||this.length)<0&&(t+=this.length),(e=e||0)<0&&(e+=this.length);var i=new H;if(t<e||t<0)return i;e<0&&(e=0),t>this.length&&(t=this.length);for(var s=this.length,r=this.tail;null!==r&&s>t;s--)r=r.prev;for(;null!==r&&s>e;s--,r=r.prev)i.push(r.value);return i},H.prototype.splice=function(e,t){e>this.length&&(e=this.length-1),e<0&&(e=this.length+e);for(var i=0,s=this.head;null!==s&&i<e;i++)s=s.next;var r=[];for(i=0;s&&i<t;i++)r.push(s.value),s=this.removeNode(s);null===s&&(s=this.tail),s!==this.head&&s!==this.tail&&(s=s.prev);for(i=2;i<arguments.length;i++)s=$(this,s,arguments[i]);return r},H.prototype.reverse=function(){for(var e=this.head,t=this.tail,i=e;null!==i;i=i.prev){var s=i.prev;i.prev=i.next,i.next=s}return this.head=t,this.tail=e,this};try{!function(e){e.prototype[Symbol.iterator]=function*(){for(let e=this.head;e;e=e.next)yield e.value}}(H)}catch(e){}const X=Symbol("max"),Y=Symbol("length"),ee=Symbol("lengthCalculator"),te=Symbol("allowStale"),ie=Symbol("maxAge"),se=Symbol("dispose"),re=Symbol("noDisposeOnSet"),ne=Symbol("lruList"),oe=Symbol("cache"),ae=Symbol("updateAgeOnGet"),le=()=>1;const ue=(e,t,i)=>{const s=e[oe].get(t);if(s){const t=s.value;if(fe(e,t)){if(ce(e,s),!e[te])return}else i&&(e[ae]&&(s.value.now=Date.now()),e[ne].unshiftNode(s));return t.value}},fe=(e,t)=>{if(!t||!t.maxAge&&!e[ie])return!1;const i=Date.now()-t.now;return t.maxAge?i>t.maxAge:e[ie]&&i>e[ie]},he=e=>{if(e[Y]>e[X])for(let t=e[ne].tail;e[Y]>e[X]&&null!==t;){const i=t.prev;ce(e,t),t=i}},ce=(e,t)=>{if(t){const i=t.value;e[se]&&e[se](i.key,i.value),e[Y]-=i.length,e[oe].delete(i.key),e[ne].removeNode(t)}};class de{constructor(e,t,i,s,r){this.key=e,this.value=t,this.length=i,this.now=s,this.maxAge=r||0}}const pe=(e,t,i,s)=>{let r=i.value;fe(e,r)&&(ce(e,i),e[te]||(r=void 0)),r&&t.call(s,r.value,r.key,e)};var me,be=class{constructor(e){if("number"==typeof e&&(e={max:e}),e||(e={}),e.max&&("number"!=typeof e.max||e.max<0))throw new TypeError("max must be a non-negative number");this[X]=e.max||1/0;const t=e.length||le;if(this[ee]="function"!=typeof t?le:t,this[te]=e.stale||!1,e.maxAge&&"number"!=typeof e.maxAge)throw new TypeError("maxAge must be a number");this[ie]=e.maxAge||0,this[se]=e.dispose,this[re]=e.noDisposeOnSet||!1,this[ae]=e.updateAgeOnGet||!1,this.reset()}set max(e){if("number"!=typeof e||e<0)throw new TypeError("max must be a non-negative number");this[X]=e||1/0,he(this)}get max(){return this[X]}set allowStale(e){this[te]=!!e}get allowStale(){return this[te]}set maxAge(e){if("number"!=typeof e)throw new TypeError("maxAge must be a non-negative number");this[ie]=e,he(this)}get maxAge(){return this[ie]}set lengthCalculator(e){"function"!=typeof e&&(e=le),e!==this[ee]&&(this[ee]=e,this[Y]=0,this[ne].forEach(e=>{e.length=this[ee](e.value,e.key),this[Y]+=e.length})),he(this)}get lengthCalculator(){return this[ee]}get length(){return this[Y]}get itemCount(){return this[ne].length}rforEach(e,t){t=t||this;for(let i=this[ne].tail;null!==i;){const s=i.prev;pe(this,e,i,t),i=s}}forEach(e,t){t=t||this;for(let i=this[ne].head;null!==i;){const s=i.next;pe(this,e,i,t),i=s}}keys(){return this[ne].toArray().map(e=>e.key)}values(){return this[ne].toArray().map(e=>e.value)}reset(){this[se]&&this[ne]&&this[ne].length&&this[ne].forEach(e=>this[se](e.key,e.value)),this[oe]=new Map,this[ne]=new j,this[Y]=0}dump(){return this[ne].map(e=>!fe(this,e)&&{k:e.key,v:e.value,e:e.now+(e.maxAge||0)}).toArray().filter(e=>e)}dumpLru(){return this[ne]}set(e,t,i){if((i=i||this[ie])&&"number"!=typeof i)throw new TypeError("maxAge must be a number");const s=i?Date.now():0,r=this[ee](t,e);if(this[oe].has(e)){if(r>this[X])return ce(this,this[oe].get(e)),!1;const n=this[oe].get(e).value;return this[se]&&(this[re]||this[se](e,n.value)),n.now=s,n.maxAge=i,n.value=t,this[Y]+=r-n.length,n.length=r,this.get(e),he(this),!0}const n=new de(e,t,r,s,i);return n.length>this[X]?(this[se]&&this[se](e,t),!1):(this[Y]+=n.length,this[ne].unshift(n),this[oe].set(e,this[ne].head),he(this),!0)}has(e){if(!this[oe].has(e))return!1;const t=this[oe].get(e).value;return!fe(this,t)}get(e){return ue(this,e,!0)}peek(e){return ue(this,e,!1)}pop(){const e=this[ne].tail;return e?(ce(this,e),e.value):null}del(e){ce(this,this[oe].get(e))}load(e){this.reset();const t=Date.now();for(let i=e.length-1;i>=0;i--){const s=e[i],r=s.e||0;if(0===r)this.set(s.k,s.v);else{const e=r-t;e>0&&this.set(s.k,s.v,e)}}}prune(){this[oe].forEach((e,t)=>ue(this,t,!1))}},ge=c((function(e,t){t.__esModule=!0,t.default=void 0;var i,s=(i=be)&&i.__esModule?i:{default:i};class r extends s.default{constructor(e){super(e),function(e,t,i){t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i}(this,"_id",0n)}newId(){return++this._id}}t.default=r})),_e=c((function(e,t){t.__esModule=!0,t.Options=t.WriteOptions=t.IteratorOptions=t.ReadOptions=void 0;var i=r(W),s=r(ge);function r(e){return e&&e.__esModule?e:{default:e}}function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class o{constructor(){n(this,"verifyChecksums",!1),n(this,"fillCache",!0),n(this,"snapshot",void 0)}}t.ReadOptions=o;t.IteratorOptions=class extends o{constructor(...e){super(...e),n(this,"start",Buffer.alloc(0))}};t.WriteOptions=class{constructor(){n(this,"sync",!1)}};t.Options=class{constructor(){n(this,"comparator",new D.BytewiseComparator),n(this,"writeBufferSize",4194304),n(this,"maxFileSize",2097152),n(this,"maxOpenFiles",1e3),n(this,"blockCache",new s.default({max:2048})),n(this,"blockSize",4096),n(this,"blockRestartInterval",16),n(this,"env",new G.NodeEnv),n(this,"infoLog",void 0),n(this,"reuseLogs",!1),n(this,"filterPolicy",new i.default),n(this,"debug",!1),n(this,"lockfileStale",1e4)}}})),ye=c((function(e,t){t.__esModule=!0,t.default=void 0;t.default=class{static wrap(e,t){if(Symbol.iterator in e){const i=e;return i.return=()=>{const e=i.next().value;return t(e),{done:!0,value:e}},i}return e.return=async()=>{try{const i=(await e.next()).value;return t(i),{done:!0,value:i}}catch(e){return t(e),{done:!0,value:e}}},e}static makeAsync(e){const t={return:async t=>{try{return{done:!0,value:e.next().value}}catch(e){return{done:!0,value:e}}},next:async t=>e.next()};return{next:t.next,[Symbol.asyncIterator]:()=>t}}}})),ve=c((function(e,t){function i(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.__esModule=!0,t.getMaxBytesForLevel=function(e){let t=10485760;for(;e>1;)t*=10,e--;return t},t.getExpandedCompactionByteSizeLimit=function(e){return 25*e.maxFileSize},t.FileSet=t.BySmallestKey=t.FileMetaData=void 0;t.FileMetaData=class{constructor(){i(this,"refs",void 0),i(this,"allowedSeeks",void 0),i(this,"fileSize",void 0),i(this,"number",void 0),i(this,"smallest",void 0),i(this,"largest",void 0),this.refs=0,this.allowedSeeks=1<<30,this.fileSize=0}};t.BySmallestKey=class{constructor(e){i(this,"internalComparator",void 0),e&&(this.internalComparator=e)}operator(e,t){const i=this.internalComparator.compare(e.smallest,t.smallest);return 0===i?e.number<t.number:i<0}};t.FileSet=class{constructor(e){i(this,"_set",void 0),i(this,"compare",void 0),this.compare=e,this._set=[]}add(e){if(this._set.find(t=>t.number===e.number))return;const t=this._set.length;if(0===t)this._set.push(e);else{for(let i=0;i<t;i++){const t=this._set[i];if(this.compare.operator(e,t))return void this._set.splice(i,0,e)}this._set.push(e)}}*iterator(){const e=this._set.length;for(let t=0;t<e;t++)yield this._set[t]}}})),we=c((function(e,t){function i(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.__esModule=!0,t.default=void 0;t.default=class{constructor(){i(this,"compactPointers",void 0),i(this,"deletedFiles",void 0),i(this,"newFiles",void 0),i(this,"_comparator",void 0),i(this,"_logNumber",void 0),i(this,"_prevLogNumber",void 0),i(this,"_lastLogNumber",void 0),i(this,"_lastSequence",void 0),i(this,"_nextFileNumber",void 0),i(this,"_hasComparator",void 0),i(this,"_hasLogNumber",void 0),i(this,"_hasPrevLogNumber",void 0),i(this,"_hasNextFileNumber",void 0),i(this,"_hasLastSequence",void 0),this._comparator="",this.deletedFiles=[],this.newFiles=[],this.compactPointers=[]}clear(){this.deletedFiles=[],this.newFiles=[],this.compactPointers=[],this._logNumber=0,this._prevLogNumber=0,this._lastSequence=0,this._nextFileNumber=0,this._comparator="",this._lastLogNumber=0,this._hasComparator=!1,this._hasLogNumber=!1,this._hasPrevLogNumber=!1,this._hasNextFileNumber=!1,this._hasLastSequence=!1}set comparator(e){this._comparator=e,this._hasComparator=!0}get comparator(){return this._comparator}set logNumber(e){this._logNumber=e,this._hasLogNumber=!0}get logNumber(){return this._logNumber||0}set prevLogNumber(e){this._prevLogNumber=e,this._hasPrevLogNumber=!0}get prevLogNumber(){return this._prevLogNumber||0}set nextFileNumber(e){this._nextFileNumber=e,this._hasNextFileNumber=!0}get nextFileNumber(){return this._nextFileNumber||0}set lastSequence(e){this._lastSequence=e,this._hasLastSequence=!0}get lastSequence(){return this._lastSequence||0}get hasComparator(){return this._hasComparator||!1}get hasLogNumber(){return this._hasLogNumber||!1}get hasPrevLogNumber(){return this._hasPrevLogNumber||!1}get hasNextFileNumber(){return this._hasNextFileNumber||!1}get hasLastSequence(){return this._hasLastSequence||!1}deleteFile(e,t){this.deletedFiles.push({level:e,fileNum:t})}addFile(e,t,i,s,r){const n=new ve.FileMetaData;n.number=t,n.fileSize=i,n.smallest=s,n.largest=r,this.newFiles.push({level:e,fileMetaData:n})}setCompactPointer(e,t){this.compactPointers.push({level:e,internalKey:t})}}})),ke=c((function(e,t){t.__esModule=!0,t.CompactionState=t.CompactionStats=t.default=void 0;var i,s=(i=we)&&i.__esModule?i:{default:i};function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class n{static targetFileSize(e){return e.maxFileSize}static maxGrandParentOverlapBytes(e){return 10*n.targetFileSize(e)}static totalFileSize(e){let t=0;for(const i of e)t+=i.fileSize;return t}static maxFileSizeForLevel(e,t){return n.targetFileSize(e)}constructor(e,t){r(this,"level",void 0),r(this,"inputVersion",void 0),r(this,"grandparents",void 0),r(this,"edit",void 0),r(this,"inputs",void 0),r(this,"grandparentIndex",void 0),r(this,"seenKey",void 0),r(this,"overlappedBytes",void 0),r(this,"_maxOutputFilesize",void 0),r(this,"levelPtrs",void 0),this.level=t,this.grandparentIndex=0,this.overlappedBytes=0,this.seenKey=!1,this.inputs=[[],[]],this._maxOutputFilesize=n.maxFileSizeForLevel(e,t),this.levelPtrs=Array.from({length:C.Config.kNumLevels},()=>0),this.edit=new s.default}get maxOutputFilesize(){return this._maxOutputFilesize}numInputFiles(e){return this.inputs[e].length}isTrivialMove(){const e=this.inputVersion.versionSet;return 1===this.numInputFiles(0)&&0===this.numInputFiles(1)&&n.totalFileSize(this.grandparents)<=n.maxGrandParentOverlapBytes(e._options)}isBaseLevelForKey(e){const t=this.inputVersion.versionSet.internalKeyComparator.userComparator;for(let i=this.level+2;i<C.Config.kNumLevels;i++){const s=this.inputVersion.files[i];for(;this.levelPtrs[i]<s.length;){const r=s[this.levelPtrs[i]];if(t.compare(e,r.largest.userKey)<=0){if(t.compare(e,r.smallest.userKey)>=0)return!1;break}this.levelPtrs[i]++}}return!0}releaseInputs(){this.inputVersion&&(this.inputVersion.unref(),delete this.inputVersion)}shouldStopBefore(e){const t=this.inputVersion.versionSet,i=t.internalKeyComparator;for(;this.grandparentIndex<this.grandparents.length&&i.compare(e,this.grandparents[this.grandparentIndex].largest)>0;)this.seenKey&&(this.overlappedBytes+=this.grandparents[this.grandparentIndex].fileSize),this.grandparentIndex++;return this.seenKey=!0,this.overlappedBytes>n.maxGrandParentOverlapBytes(t._options)&&(this.overlappedBytes=0,!0)}addInputDeletions(e){for(let t=0;t<2;t++)for(let i=0;i<this.inputs[t].length;i++)e.deleteFile(this.level+t,this.inputs[t][i].number)}}t.default=n;t.CompactionStats=class{constructor(){r(this,"times",void 0),r(this,"bytesRead",void 0),r(this,"bytesWritten",void 0),this.times=0,this.bytesRead=0,this.bytesWritten=0}add(e){this.times+=e.times,this.bytesRead+=e.bytesRead,this.bytesWritten+=e.bytesWritten}};t.CompactionState=class{constructor(e){r(this,"outputs",[]),r(this,"smallestSnapshot",void 0),r(this,"compaction",void 0),r(this,"outfile",void 0),r(this,"builder",void 0),r(this,"totalBytes",void 0),this.compaction=e,this.smallestSnapshot=0,this.totalBytes=0}currentOutput(){return this.outputs[this.outputs.length-1]}}})),Se=c((function(e,t){t.__esModule=!0,t.default=t.StatusError=void 0;var i,s,n=(i=r)&&i.__esModule?i:{default:i};function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}!function(e){e[e.kOk=0]="kOk",e[e.kNotFound=1]="kNotFound",e[e.kCorruption=2]="kCorruption",e[e.kNotSupported=3]="kNotSupported",e[e.kInvalidArgument=4]="kInvalidArgument",e[e.kIOError=5]="kIOError"}(s||(s={}));class a extends Error{constructor(e,t){super(t),o(this,"_code",void 0),this._code=e}}t.StatusError=a;class l{static createNotFound(e){return new l(Promise.reject(new a(s.kNotFound,e)))}static createCorruption(e){return new l(Promise.reject(new a(s.kCorruption,e)))}constructor(e){o(this,"_error",void 0),o(this,"_promise",void 0),o(this,"_code",void 0),o(this,"_finish",void 0),this._promise=e,this._finish=!1}get promise(){return this._promise}get error(){return this._error}async wait(){if(!this._finish)try{await this._promise}catch(e){e._code&&(this._code=e._code),this._error=e}finally{this._finish=!0}}async ok(){return await this.wait(),!this._error}message(){if((0,n.default)(this._finish),this._error)return this._error.message}isNotFound(){return(0,n.default)(this._finish),this._code===s.kNotFound}isCorruption(){return(0,n.default)(this._finish),this._code===s.kCorruption}isIOError(){return(0,n.default)(this._finish),this._code===s.kIOError}isNotSupportedError(){return(0,n.default)(this._finish),this._code===s.kNotSupported}isInvalidArgument(){return(0,n.default)(this._finish),this._code===s.kNotSupported}}t.default=l})),Be=c((function(e,t){t.__esModule=!0,t.default=void 0;var i,s=l(r),n=l(L),o=l(ke),a=l(Se);function l(e){return e&&e.__esModule?e:{default:e}}function u(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}!function(e){e[e.kNotFound=0]="kNotFound",e[e.kFound=1]="kFound",e[e.kDeleted=2]="kDeleted",e[e.kCorrupt=3]="kCorrupt"}(i||(i={}));class f{constructor(){u(this,"state",void 0),u(this,"ucmp",void 0),u(this,"userKey",void 0),u(this,"value",void 0)}}class h{constructor(){u(this,"s",void 0),u(this,"vset",void 0),u(this,"options",void 0),u(this,"ikey",void 0),u(this,"lastFileRead",void 0),u(this,"lastFileReadLevel",void 0),u(this,"stats",void 0),u(this,"found",void 0),u(this,"saver",new f)}static async match(e,t,s){if(!(e instanceof h))return Promise.resolve(!1);if(!e.stats.seekFile&&e.lastFileRead&&(e.stats.seekFile=e.lastFileRead,e.stats.seekFileLevel=e.lastFileReadLevel),e.lastFileRead=s,e.lastFileReadLevel=t,e.s=await e.vset.tableCache.get(e.options,s.number,s.fileSize,e.ikey,e.saver,c.saveValue),!await e.s.ok()){if(!e.s.isNotFound())return!1;e.s=new a.default}switch(e.saver.state){case i.kNotFound:return!0;case i.kFound:return e.found=!0,!1;case i.kDeleted:return!1;case i.kCorrupt:return e.s=a.default.createCorruption("corrupted key for "+e.saver.userKey.toString()),e.found=!0,!1}return!1}}class c{static saveValue(e,t,s){if(!(e instanceof f))return;const r=new C.ParsedInternalKey;(0,C.parseInternalKey)(t,r)?0==e.ucmp.compare(r.userKey,e.userKey)&&(e.state=r.valueType==C.ValueType.kTypeValue?i.kFound:i.kDeleted,e.state==i.kFound&&(e.value=Buffer.concat([s.buffer]))):e.state=i.kCorrupt}static*levelFileNumIterator(e,t){for(const e of t){const t=Buffer.alloc(16);t.fill((0,x.encodeFixed64)(e.number),0,8),t.fill((0,x.encodeFixed64)(e.fileSize),8,16),yield{key:e.largest,value:new n.default(t)}}}static afterFile(e,t,i){return!!t&&e.compare(t,i.largest.userKey)>0}static beforeFile(e,t,i){return!!t&&e.compare(t,i.smallest.userKey)<0}constructor(e){u(this,"versionSet",void 0),u(this,"next",void 0),u(this,"prev",void 0),u(this,"refs",void 0),u(this,"fileToCompact",void 0),u(this,"fileToCompactLevel",void 0),u(this,"compactionScore",void 0),u(this,"compactionLevel",void 0),u(this,"files",void 0),this.versionSet=e,this.next=this,this.prev=this,this.refs=0,this.fileToCompactLevel=-1,this.compactionScore=-1,this.compactionLevel=-1;new ve.BySmallestKey(e.internalKeyComparator);this.files=Array.from({length:C.Config.kNumLevels},()=>[])}ref(){this.refs++}unref(){(0,s.default)(this.refs>=1),this.refs--,this.refs}async get(e,t){delete t.seekFile,t.seekFileLevel=-1;const s=new h;return s.found=!1,s.stats=t,s.lastFileReadLevel=-1,s.options={},s.ikey=e.internalKey,s.vset=this.versionSet,s.saver.state=i.kNotFound,s.saver.ucmp=this.versionSet.internalKeyComparator.userComparator,s.saver.userKey=e.userKey,await this.forEachOverlapping(e.userKey,e.internalKey,s,h.match),s.found?new a.default(Promise.resolve(s.saver.value)):a.default.createNotFound()}async forEachOverlapping(e,t,i,s){const r=this.versionSet.internalKeyComparator.userComparator,n=[];for(let t=0;t<this.files[0].length;t++){const i=this.files[0][t];r.compare(e,i.smallest.userKey)>=0&&r.compare(e,i.largest.userKey)<=0&&n.push(i)}if(n.length>0){n.sort((e,t)=>e.number>t.number?-1:1);for(let e=0;e<n.length;e++)if(!await s(i,0,n[e]))return}for(let n=0;n<C.Config.kNumLevels;n++){const o=this.files[n].length;if(0===o)continue;const a=this.findFile(this.versionSet.internalKeyComparator,this.files[n],t);if(a<o){const t=this.files[n][a];if(r.compare(e,t.smallest.userKey)<0);else if(!await s(i,n,t))return}}}someFileOverlapsRange(e,t,i,s,r){const n=e.userComparator;if(!t){for(let e=0;e<i.length;e++){const t=i[e];if(!c.afterFile(n,s,t)&&!c.beforeFile(n,r,t))return!0}return!1}let o=0;if(s){const t=new C.InternalKey(s,C.InternalKey.kMaxSequenceNumber,C.kValueTypeForSeek);o=this.findFile(e,i,t)}return!(o>=i.length)&&!c.beforeFile(n,r,i[o])}findFile(e,t,i){let s=0,r=t.length;for(;s<r;){const n=Math.floor((s+r)/2),o=t[n];e.compare(o.largest,i)<0?s=n+1:r=n}return r}overlapInLevel(e,t,i){return this.someFileOverlapsRange(this.versionSet.internalKeyComparator,e>0,this.files[e],t,i)}getOverlappingInputs(e,t,i){(0,s.default)(e>=0),(0,s.default)(e<C.Config.kNumLevels);let r=[],o=t?t.userKey:new n.default,a=i?i.userKey:new n.default;const l=this.versionSet.internalKeyComparator.userComparator;for(let s=0;s<this.files[e].length;){const n=this.files[e][s++],u=n.smallest.userKey,f=n.largest.userKey;t&&l.compare(f,o)<0||i&&l.compare(u,a)>0||(r.push(n),0===e&&(t&&l.compare(u,o)<0?(o=u,r=[],s=0):i&&l.compare(f,a)>0&&(a=f,r=[],s=0)))}return r}pickLevelForMemTableOutput(e,t){let i=0;if(!this.overlapInLevel(0,e,t)){const s=new C.InternalKey(e,C.InternalKey.kMaxSequenceNumber,C.kValueTypeForSeek),r=new C.InternalKey(t,new C.SequenceNumber(0),C.ValueType.kTypeValue);let n=[];for(;i<C.Config.kMaxMemCompactLevel&&!this.overlapInLevel(i+1,e,t);){if(i+2<C.Config.kNumLevels){n=this.getOverlappingInputs(i+2,s,r);if(o.default.totalFileSize(n)>o.default.maxGrandParentOverlapBytes(this.versionSet._options))break}i++}}return i}updateStats(e){return!1}}t.default=c})),Fe=c((function(e,t){t.__esModule=!0,t.getCurrentFilename=function(e){return r.default.resolve(e,"CURRENT")},t.getLogFilename=function(e,t){return r.default.resolve(e,o(t)+".log")},t.getTableFilename=function(e,t){return r.default.resolve(e,o(t)+".ldb")},t.getManifestFilename=function(e,t){return r.default.resolve(e,"MANIFEST-"+o(t))},t.getLockFilename=function(e){return r.default.resolve(e,"LOCK")},t.getInfoLogFilename=function(e){return r.default.resolve(e,"LOG")},t.getOldInfoLogFilename=function(e){return r.default.resolve(e,"LOG.old")},t.parseFilename=function(e){const t=new a;if("CURRENT"===e)t.number=0,t.type=C.FileType.kCurrentFile;else if("LOCK"===e)t.number=0,t.type=C.FileType.kDBLockFile;else if("LOG"===e||"LOG.old"===e)t.number=0,t.type=C.FileType.kInfoLogFile;else if(e.startsWith("MANIFEST-")){const i=Number(e.substr("MANIFEST-".length));if(isNaN(i))return t.isInternalFile=!1,t;t.number=i,t.type=C.FileType.kDescriptorFile}else{const i=Number(e.split(".")[0]);if(isNaN(i))return t.isInternalFile=!1,t;const s=e.substr(e.split(".")[0].length);if(".log"===s)t.type=C.FileType.kLogFile;else if(".ldb"===s)t.type=C.FileType.kTableFile;else{if(".dbtmp"!==s)return t.isInternalFile=!1,t;t.type=C.FileType.kTempFile}t.number=i}return t},t.InternalFile=void 0;var i,r=(i=s)&&i.__esModule?i:{default:i};function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e){let t=String(e);for(;t.length<6;)t="0"+t;return t}class a{constructor(){n(this,"isInternalFile",!0),n(this,"filename",void 0),n(this,"number",void 0),n(this,"type",void 0)}}t.InternalFile=a})),Le=c((function(e,t){t.__esModule=!0,t.default=void 0;var i,s=(i=r)&&i.__esModule?i:{default:i};function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.default=class{constructor(e,t){n(this,"_versionSet",void 0),n(this,"_base",void 0),n(this,"_levels",void 0),n(this,"cmp",void 0),this._versionSet=e,this._base=t,this._levels=Array.from({length:C.Config.kNumLevels},()=>({addedFiles:new ve.FileSet(this.cmp),deletedFiles:new Set})),t.ref();const i=new ve.BySmallestKey(e.internalKeyComparator);this.cmp=i;for(let e=0;e<C.Config.kNumLevels;e++)this._levels[e].addedFiles=new ve.FileSet(i)}apply(e){for(let t=0;t<e.compactPointers.length;t++){const i=e.compactPointers[t].level;this._versionSet.compactPointers[i]=e.compactPointers[t].internalKey}for(let t=0;t<e.deletedFiles.length;t++){const{level:i,fileNum:s}=e.deletedFiles[t];this._levels[i].deletedFiles.add(s)}for(const t of e.newFiles){const{level:e,fileMetaData:i}=t;i.refs=1,i.allowedSeeks=Math.floor(t.fileMetaData.fileSize/16384),i.allowedSeeks<100&&(i.allowedSeeks=100),this._levels[e].deletedFiles.delete(i.number),this._levels[e].addedFiles.add(i)}}saveTo(e){const t=new ve.BySmallestKey(this._versionSet.internalKeyComparator);for(let i=0;i<C.Config.kNumLevels;i++){const s=this._levels[i].addedFiles.iterator(),r=this._base.files[i].sort((e,i)=>t.operator(e,i)?-1:1);let n=s.next(),o=0;for(;0!==r.length;){const a=r[o++];if(n.done||t.operator(a,n.value)?this.maybeAddFile(e,i,a):(o--,this.maybeAddFile(e,i,n.value),n=s.next()),o>=r.length)break}for(;!n.done;)this.maybeAddFile(e,i,n.value),n=s.next()}}maybeAddFile(e,t,i){if(this._levels[t].deletedFiles.has(i.number));else{const r=e.files[t];t>0&&r.length>0&&(0,s.default)(this._versionSet.internalKeyComparator.compare(r[r.length-1].largest,i.smallest)<0),i.refs++,e.files[t].push(i)}}}})),xe=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=l(R),s=l(r),n=l(F),o=l(L),a=l(we);function l(e){return e&&e.__esModule?e:{default:e}}function u(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class f{static from(e){const t=e.readUInt16BE(4),i=e.readUInt8(6),r=new o.default(e.slice(7,7+t));(0,s.default)(t===r.length);return new f(i,r)}static add(e){const t=[];return e.hasComparator&&(t.push(Buffer.from([C.VersionEditTag.kComparator])),t.push(Buffer.from(n.default.encode(e.comparator.length))),t.push(Buffer.from(e.comparator))),e.hasLogNumber&&(t.push(Buffer.from([C.VersionEditTag.kLogNumber])),t.push(Buffer.from(n.default.encode(e.logNumber)))),e.hasPrevLogNumber&&(t.push(Buffer.from([C.VersionEditTag.kPrevLogNumber])),t.push(Buffer.from(n.default.encode(e.prevLogNumber)))),e.hasNextFileNumber&&(t.push(Buffer.from([C.VersionEditTag.kNextFileNumber])),t.push(Buffer.from(n.default.encode(e.nextFileNumber)))),e.hasLastSequence&&(t.push(Buffer.from([C.VersionEditTag.kLastSequence])),t.push(Buffer.from(n.default.encode(e.lastSequence)))),e.compactPointers.forEach(e=>{t.push(Buffer.from([C.VersionEditTag.kCompactPointer])),t.push(Buffer.from(n.default.encode(e.level))),t.push(Buffer.from(n.default.encode(e.internalKey.length))),t.push(e.internalKey.buffer)}),e.deletedFiles.forEach(e=>{t.push(Buffer.from([C.VersionEditTag.kDeletedFile])),t.push(Buffer.from(n.default.encode(e.level))),t.push(Buffer.from(n.default.encode(e.fileNum)))}),e.newFiles.forEach(e=>{t.push(Buffer.from([C.VersionEditTag.kNewFile])),t.push(Buffer.from(n.default.encode(e.level))),t.push(Buffer.from(n.default.encode(e.fileMetaData.number))),t.push(Buffer.from(n.default.encode(e.fileMetaData.fileSize))),t.push(Buffer.from(n.default.encode(e.fileMetaData.smallest.length))),t.push(e.fileMetaData.smallest.buffer),t.push(Buffer.from(n.default.encode(e.fileMetaData.largest.length))),t.push(e.fileMetaData.largest.buffer)}),new o.default(Buffer.concat(t))}static decode(e){let t=0;const i=new a.default,r=e.buffer;for(;t<e.length;){const e=r.readUInt8(t);if(t+=1,e!==C.VersionEditTag.kComparator)if(e!==C.VersionEditTag.kLogNumber)if(e!==C.VersionEditTag.kPrevLogNumber)if(e!==C.VersionEditTag.kNextFileNumber)if(e!==C.VersionEditTag.kLastSequence)if(e!==C.VersionEditTag.kCompactPointer)if(e!==C.VersionEditTag.kDeletedFile)if(e!==C.VersionEditTag.kNewFile);else{const e=n.default.decode(r.slice(t));t+=n.default.decode.bytes;const s=n.default.decode(r.slice(t));t+=n.default.decode.bytes;const a=n.default.decode(r.slice(t));t+=n.default.decode.bytes;const l=n.default.decode(r.slice(t));t+=n.default.decode.bytes;const u=r.slice(t,t+l);t+=l;const f=n.default.decode(r.slice(t));t+=n.default.decode.bytes;const h=r.slice(t,t+f);t+=f;const c=new ve.FileMetaData;c.number=s,c.fileSize=a,c.smallest=C.InternalKey.from(new o.default(u)),c.largest=C.InternalKey.from(new o.default(h)),i.newFiles.push({level:e,fileMetaData:c})}else{const e=n.default.decode(r.slice(t));t+=n.default.decode.bytes;const s=n.default.decode(r.slice(t));t+=n.default.decode.bytes,i.deletedFiles.push({level:e,fileNum:s})}else{const e=n.default.decode(r.slice(t));t+=n.default.decode.bytes;const a=n.default.decode(r.slice(t));t+=n.default.decode.bytes,(0,s.default)(r.length>=t+a);const l=new o.default(r.slice(t,t+a));t+=a,i.compactPointers.push({level:e,internalKey:new C.InternalKey(l)})}else{const e=n.default.decode(r.slice(t));t+=n.default.decode.bytes,i.lastSequence=e}else{const e=n.default.decode(r.slice(t));t+=n.default.decode.bytes,i.nextFileNumber=e}else{const e=n.default.decode(r.slice(t));t+=n.default.decode.bytes,i.prevLogNumber=e}else{const e=n.default.decode(r.slice(t));t+=n.default.decode.bytes,i.logNumber=e}else{const e=n.default.decode(r.slice(t));t+=n.default.decode.bytes;const s=r.slice(t,t+e);t+=e,i.comparator=s.toString()}}return i}constructor(e,t){u(this,"data",void 0),u(this,"type",void 0),this.type=e,this.data=new o.default(t)}get length(){return this.data.length+7}get size(){return this.length}get buffer(){const e=Buffer.from((0,V.createHexStringFromDecimal)(this.data.length),"hex"),t=Buffer.from([this.type]),s=(0,i.default)(Buffer.concat([t,this.data.buffer]));return Buffer.concat([s,e,t,this.data.buffer])}}t.default=f})),Ce=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=n(r),s=n(L);function n(e){return e&&e.__esModule?e:{default:e}}t.default=class{constructor(e){var t,i,s;s=void 0,(i="_file")in(t=this)?Object.defineProperty(t,i,{value:s,enumerable:!0,configurable:!0,writable:!0}):t[i]=s,this._file=e}async close(){if(this._file){const e=this._file;delete this._file;try{await e.close()}catch(e){}}}async*iterator(){const e=Buffer.from(new ArrayBuffer(V.kBlockSize));let t=-1,r=Buffer.alloc(0),n=null,o=0;for(;;){if(-1===t||o>=V.kBlockSize-V.kHeaderSize){const i=++t*V.kBlockSize,{bytesRead:s}=await this._file.read(e,0,V.kBlockSize,i);if(0===s)return void await this.close();o=0;continue}const a=this.readPhysicalRecord(Buffer.from(e.slice(o)));if(o+=a.length+V.kHeaderSize,a.type===V.RecordType.kFullType){const e=new s.default(a.data.buffer);yield e}else if(a.type===V.RecordType.kLastType){(0,i.default)(n!==V.RecordType.kLastType),r=Buffer.concat([r,a.data.buffer]);const e=new s.default(r);r=Buffer.alloc(0),yield e}else a.type===V.RecordType.kFirstType?((0,i.default)(n!==V.RecordType.kFirstType),r=a.data.buffer):a.type===V.RecordType.kMiddleType?r=Buffer.concat([r,a.data.buffer]):a.type===V.RecordType.kZeroType&&(n=a.type,o=V.kBlockSize);n=a.type}}readPhysicalRecord(e){const t=e.slice(0,V.kHeaderSize),i=t[6],r=255&t[4]|(255&t[5])<<8;return{length:r,data:new s.default(e.slice(V.kHeaderSize,V.kHeaderSize+r)),type:i}}}})),Ne=c((function(e,t){t.__esModule=!0,t.default=void 0;var i,s=(i=r)&&i.__esModule?i:{default:i};function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.default=class{constructor(e,t,i){n(this,"_icmp",void 0),n(this,"_list",void 0),n(this,"_num",void 0),n(this,"_cache",void 0),this._icmp=e,this._list=t,this._num=i,this._cache=new Array(i)}async*iterator(){if((0,s.default)(this._num>=0),0!==this._num)if(1!==this._num)for(;;){const e=await this.findSmallest();if(!e)break;yield e}else yield*this._list[0]}async findSmallest(){let e=null,t=-1;for(let i=0;i<this._num;i++){const s=this._cache[i]||await this._list[i].next();this._cache[i]=s,s.done||(null===e||this._icmp.compare(s.value.key,e.key)<0)&&(e=s.value,t=i)}for(let e=0;e<this._num;e++)e===t&&(this._cache[e]=null);return e}}})),Ie=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=p(r),s=p(Be),n=p(L),o=p(Se),a=p(Le),l=p(xe),u=p(Ce),f=p(we),h=p(q),c=p(ke),d=p(Ne);function p(e){return e&&e.__esModule?e:{default:e}}function m(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.default=class{constructor(e,t,i,r){m(this,"compactPointers",void 0),m(this,"_current",void 0),m(this,"_dummyVersions",void 0),m(this,"hasLogNumber",void 0),m(this,"hasNextFileNumber",void 0),m(this,"hasPrevLogNumber",void 0),m(this,"logNumber",0),m(this,"prevLogNumber",0),m(this,"_lastSequence",0),m(this,"hasLastSequence",void 0),m(this,"manifestFileNumber",0),m(this,"nextFileNumber",2),m(this,"_dbpath",void 0),m(this,"_options",void 0),m(this,"internalKeyComparator",void 0),m(this,"tableCache",void 0),m(this,"manifestWriter",void 0),m(this,"recover",async()=>{const e={},t=await this._options.env.readFile((0,Fe.getCurrentFilename)(this._dbpath),"utf8");if(!t||"\n"!==t[t.length-1])throw new Error("Invalid format of CURRENT file.");let i=!1,r=!1,n=!1,o=!1,f=0,h=0,c=0,d=0;const p=new a.default(this,this._current),m=t.substr(0,t.length-1),b=Number(m.substr("MANIFEST-".length)),g=new u.default(await this._options.env.open((0,Fe.getManifestFilename)(this._dbpath,b),"r"));for await(const e of g.iterator()){const t=l.default.decode(e);p.apply(t),t.hasLogNumber&&(f=t.logNumber,i=!0),t.hasPrevLogNumber&&(c=t.prevLogNumber,n=!0),t.hasNextFileNumber&&(h=t.nextFileNumber,r=!0),t.hasLastSequence&&(d=t.lastSequence,o=!0)}if(!r)throw new Error("no meta-nextfile entry in descriptor");if(!i)throw new Error("no meta-lognumber entry in descriptor");if(!o)throw new Error("no last-sequence-number entry in descriptor");n||(c=0),this.markFileNumberUsed(c),this.markFileNumberUsed(f);const _=new s.default(this);return p.saveTo(_),this.finalize(_),this.appendVersion(_),this.manifestFileNumber=h,this.nextFileNumber=h+1,this.lastSequence=d,this.logNumber=f,this.prevLogNumber=c,this.reuseManifest()||(e.saveManifest=!0),await g.close(),e}),this._dbpath=e,this._options=t,this.tableCache=i,this.internalKeyComparator=r,this._dummyVersions=new s.default(this),this.appendVersion(new s.default(this)),this.compactPointers=[]}get lastSequence(){return this._lastSequence}set lastSequence(e){this._lastSequence=e}get current(){return this._current}getLevelSummary(){let e="files [ ";for(let t=0;t<this._current.files.length;t++)e+=this._current.files[t].length+" ";return e+="]",e}compactRange(e,t,i){let s=this._current.getOverlappingInputs(e,t,i);if(0===s.length)return;if(e>0){const t=this.maxFileSizeForLevel(this._options,e);let i=0;for(let e=0;e<s.length;e++)if(i+=s[e].fileSize,i>=t){s=s.slice(0,e+1);break}}const r=new c.default(this._options,e);return r.inputVersion=this._current,r.inputVersion.ref(),r.inputs[0]=s,this.setupOtherInputs(r),r}maxFileSizeForLevel(e,t){return e.maxFileSize}getNextFileNumber(){return this.nextFileNumber++}getNumLevelFiles(e){return(0,i.default)(e>=0),(0,i.default)(e<=C.Config.kNumLevels),this._current.files[e].length}markFileNumberUsed(e){this.nextFileNumber<=e&&(this.nextFileNumber=e+1)}finalize(e){let t=-1,i=-1;for(let s=0;s<C.Config.kNumLevels;s++){let r=0;if(0===s)r=e.files[s].length/C.Config.kL0CompactionTrigger;else{const t=this.getTotalBytes(e.files[s]);this._options.debug&&(0,G.Log)(this._options.infoLog,`DEBUG level=${s} levelBytes=${t}`),r=t/(0,ve.getMaxBytesForLevel)(s)}r>i&&(i=r,t=s)}e.compactionLevel=t,e.compactionScore=i}getTotalBytes(e){let t=0;for(const i of e)t+=i.fileSize;return t}async logAndApply(e){e.hasLogNumber?((0,i.default)(e.logNumber>=this.logNumber),(0,i.default)(e.logNumber<this.nextFileNumber)):e.logNumber=this.logNumber,e.hasPrevLogNumber||(e.prevLogNumber=this.prevLogNumber),e.nextFileNumber=this.nextFileNumber,e.lastSequence=this.lastSequence;const t=new s.default(this),r=new a.default(this,this._current);r.apply(e),r.saveTo(t),this.finalize(t);let n="",u=new o.default;if(this.manifestWriter||(n=(0,Fe.getManifestFilename)(this._dbpath,this.manifestFileNumber),e.nextFileNumber=this.nextFileNumber,this.manifestWriter=new h.default(await this._options.env.open(n,"a")),this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG writeSnapshot starting..."),u=this.writeSnapshot(this.manifestWriter)),await u.ok()){const t=l.default.add(e);u=new o.default(this.manifestWriter.addRecord(t))}else this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG writeSnapshot fail");return await u.ok()&&n.length>0&&(u=new o.default(this.writeCurrentFile(this._dbpath,this.manifestFileNumber))),await u.ok()?(n&&(await this.manifestWriter.close(),delete this.manifestWriter),(0,G.Log)(this._options.infoLog,"DEBUG LogAndApply success, Install the new version"),this.appendVersion(t),this.logNumber=e.logNumber,this.prevLogNumber=e.prevLogNumber):((0,G.Log)(this._options.infoLog,"DEBUG LogAndApply fail, Delete ver"),n&&(await this.manifestWriter.close(),delete this.manifestWriter,await this._options.env.unlink(n))),u}needsCompaction(){return this._current.compactionScore>=1||!!this._current.fileToCompact}appendVersion(e){(0,i.default)(0===e.refs),(0,i.default)(e!==this._current),this._current&&this._current.unref(),this._current=e,e.ref(),e.prev=this._dummyVersions.prev,e.next=this._dummyVersions,e.prev.next=e,e.next.prev=e}reuseManifest(){return!1}writeSnapshot(e){const t=new f.default;t.comparator=this.internalKeyComparator.userComparator.getName();for(let e=0;e<C.Config.kNumLevels;e++)if(this.compactPointers[e]&&0!==this.compactPointers[e].length){const i=new C.InternalKey;i.decodeFrom(this.compactPointers[e]),t.setCompactPointer(e,i)}for(let e=0;e<C.Config.kNumLevels;e++){const i=this._current.files[e];for(let s=0;s<i.length;s++){const r=i[s];t.addFile(e,r.number,r.fileSize,r.smallest,r.largest)}}const i=l.default.add(t);return new o.default(e.addRecord(i))}async writeCurrentFile(e,t){const s=(0,Fe.getCurrentFilename)(e);let r=(0,Fe.getManifestFilename)(e,t);(0,i.default)(r.startsWith(e+"/")),r=r.substr(e.length+1),await this._options.env.writeFile(s,r+"\n")}pickCompaction(){const e=this._current.compactionScore>=1,t=!!this._current.fileToCompact;let s,r;if(e){r=this._current.compactionLevel,(0,i.default)(r>=0),(0,i.default)(r+1<C.Config.kNumLevels),s=new c.default(this._options,r);for(const e of this._current.files[r])if(!this.compactPointers[r]||0===this.compactPointers[r].length||this.internalKeyComparator.compare(e.largest,this.compactPointers[r])>0){s.inputs[0].push(e);break}0===s.inputs[0].length&&s.inputs[0].push(this._current.files[r][0])}else{if(!t)return;r=this._current.fileToCompactLevel,s=new c.default(this._options,r),s.inputs[0].push(this._current.fileToCompact)}if(s.inputVersion=this.current,s.inputVersion.ref(),0===r){const e=new C.InternalKey,t=new C.InternalKey;this.getRange(s.inputs[0],e,t),s.inputs[0]=this._current.getOverlappingInputs(0,e,t),(0,i.default)(s.inputs[0].length>0)}return this.setupOtherInputs(s),s}getRange(e,t,s){(0,i.default)(e.length>0),t.clear(),s.clear();for(let i=0;i<e.length;i++){const r=e[i];0===i?(t.buffer=r.smallest.buffer,s.buffer=r.largest.buffer):(this.internalKeyComparator.compare(r.smallest,t)<0&&(t.buffer=r.smallest.buffer),this.internalKeyComparator.compare(r.largest,s)>0&&(s.buffer=r.largest.buffer))}}getRange2(e,t,i,s){const r=e.concat(t);this.getRange(r,i,s)}findLargestKey(e,t,i){if(0===t.length)return!1;i.buffer=t[0].largest.buffer;for(let s=0;s<t.length;s++){const r=t[s];e.compare(r.largest,i)>0&&(i.buffer=r.largest.buffer)}return!0}addBoundaryInputs(e,t,i){let s=new C.InternalKey;if(this.findLargestKey(e,i,s))for(;;){const r=this.findSmallestBoundaryFile(e,t,s);if(!r)break;s=r.largest,i.push(r)}}findSmallestBoundaryFile(e,t,i){const s=e.userComparator;let r;for(let n=0;n<t.length;n++){const o=t[n];e.compare(o.smallest,i)>0&&0===s.compare(o.smallest.userKey,i.userKey)&&(!r||e.compare(o.smallest,r.smallest)<0)&&(r=o)}return r}setupOtherInputs(e){const t=e.level;let i=new C.InternalKey,s=new C.InternalKey;this.addBoundaryInputs(this.internalKeyComparator,this._current.files[t],e.inputs[0]),this.getRange(e.inputs[0],i,s),e.inputs[1]=this.current.getOverlappingInputs(t+1,i,s);const r=new C.InternalKey,o=new C.InternalKey;if(this.getRange2(e.inputs[0],e.inputs[1],r,o),e.inputs.length>0){const n=this.current.getOverlappingInputs(t,r,o);this.addBoundaryInputs(this.internalKeyComparator,this._current.files[t],n);const a=this.getTotalBytes(e.inputs[0]),l=this.getTotalBytes(e.inputs[1]),u=this.getTotalBytes(n);if(n.length>e.inputs[0].length&&l+u<(0,ve.getExpandedCompactionByteSizeLimit)(this._options)){const f=new C.InternalKey,h=new C.InternalKey;this.getRange(n,f,h);const c=this._current.getOverlappingInputs(t+1,f,h);c.length===e.inputs[1].length&&((0,G.Log)(this._options.infoLog,`Expanding@${t} ${e.inputs[0].length}+${e.inputs[1].length} (${a}+${l} bytes) to ${u}+${c.length} (${u}+${l} bytes)`),i=f,s=h,e.inputs[0]=n,e.inputs[1]=c,this.getRange2(e.inputs[0],e.inputs[1],r,o))}}t+2<C.Config.kNumLevels&&(e.grandparents=this._current.getOverlappingInputs(t+2,r,o)),this.compactPointers[t]=new n.default(s.buffer),e.edit.compactPointers.push({level:t,internalKey:s})}addLiveFiles(e){for(let t=this._dummyVersions.next;t!=this._dummyVersions;t=t.next)for(let i=0;i<C.Config.kNumLevels;i++){const s=t.files[i];for(let t=0;t<s.length;t++)e.add(s[t].number)}}async*makeInputIterator(e){let t=0;const s=0===e.level?e.inputs[0].length+1:2,r=Array.from({length:s});for(let i=0;i<2;i++)if(e.inputs[i].length>0)if(e.level+i===0){const s=e.inputs[i];for(let e=0;e<s.length;e++)r[t++]=this.tableCache.entryIterator(this._options,s[e].number,s[e].fileSize)}else{const s=e.inputs[i];r[t++]=this.levelFileEntryIterator(s)}(0,i.default)(t<=s);const n=new d.default(this.internalKeyComparator,r,t);yield*n.iterator()}async*levelFileEntryIterator(e){for(const t of s.default.levelFileNumIterator(this.internalKeyComparator,e)){const e=(0,x.decodeFixed64)(t.value.buffer.slice(0,8)),i=(0,x.decodeFixed64)(t.value.buffer.slice(8));yield*this.tableCache.entryIterator(this._options,e,i)}}}})),Te=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=r(F),s=r(L);function r(e){return e&&e.__esModule?e:{default:e}}t.default=class{static add(e,t){return new s.default(Buffer.concat([Buffer.from([C.ValueType.kTypeValue]),Buffer.from(i.default.encode(e.length)),e.buffer,Buffer.from(i.default.encode(t.length)),t.buffer]))}static del(e){return new s.default(Buffer.concat([Buffer.from([C.ValueType.kTypeDeletion]),Buffer.from(i.default.encode(e.length)),e.buffer]))}}})),Ke=c((function(e,t){t.__esModule=!0,t.WriteBatch=t.WriteBatchInternal=void 0;var i=a(r),s=a(F),n=a(L),o=a(Te);function a(e){return e&&e.__esModule?e:{default:e}}function l(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class u{static byteSize(e){return e.buffers.reduce((e,t)=>e+t.length,0)}static insert(e,t){const i=u.getSequence(e);for(const s of e.iterator()){const{type:e,key:r,value:n}=s;t.add(i,e,r,n),i.value+=1}}static getContents(e){return Buffer.concat([e.head,...e.buffers])}static setContents(e,t){(0,i.default)(t.length>=u.kHeader),e.head=t.slice(0,this.kHeader),e.buffers=[t.slice(this.kHeader)]}static setSequence(e,t){e.head.fill(new C.SequenceNumber(t).toFixed64Buffer(),0,7)}static getSequence(e){return new C.SequenceNumber((0,x.decodeFixed64)(e.head.slice(0,8)))}static setCount(e,t){e.head.fill((0,x.encodeFixed32)(t),8,11)}static getCount(e){return(0,x.decodeFixed32)(e.head.slice(8,12))}static append(e,t){u.setCount(e,u.getCount(t)+u.getCount(e)),e.buffers=e.buffers.concat(t.buffers)}}t.WriteBatchInternal=u,l(u,"kHeader",12);t.WriteBatch=class{constructor(){l(this,"buffers",[]),l(this,"head",Buffer.alloc(u.kHeader))}put(e,t){const i=o.default.add(new n.default(e),new n.default(t));this.buffers.push(i.buffer),u.setCount(this,u.getCount(this)+1)}del(e){const t=o.default.del(new n.default(e));this.buffers.push(t.buffer),u.setCount(this,u.getCount(this)+1)}clear(){this.buffers=[],this.head=Buffer.alloc(u.kHeader)}*iterator(){let e=0;const t=this.buffers.length;for(;e<t;){const t=this.buffers[e],i=t.length;let r=0;for(;r<i;){const e=t.readUInt8(r);r++;const i=s.default.decode(t,r);r+=s.default.decode.bytes;const o=t.slice(r,r+i);if(r+=i,e===C.ValueType.kTypeDeletion){yield{type:e,key:new n.default(o),value:new n.default};continue}const a=s.default.decode(t,r);r+=s.default.decode.bytes;const l=t.slice(r,r+a);r+=a,yield{type:e,key:new n.default(o),value:new n.default(l)}}e++}}}})),ze=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=n(F),s=n(r);function n(e){return e&&e.__esModule?e:{default:e}}function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class a{constructor(e){o(this,"_buffer",void 0),(0,s.default)(48===e.length),this._buffer=e}get indexHandle(){const e=this.get();return{offset:e.indexOffset,size:e.indexSize}}get metaIndexHandle(){const e=this.get();return{offset:e.metaIndexOffset,size:e.metaIndexSize}}get buffer(){return this._buffer}set metaIndexOffset(e){const t={...this.get(),metaIndexOffset:e};this.put(t)}set metaIndexSize(e){const t={...this.get(),metaIndexSize:e};this.put(t)}set indexOffset(e){const t={...this.get(),indexOffset:e};this.put(t)}set indexSize(e){const t={...this.get(),indexSize:e};this.put(t)}get(){const e=this.buffer;if(!e)return{metaIndexOffset:0,metaIndexSize:0,indexOffset:0,indexSize:0};let t=0;const s=i.default.decode(e,t);t+=i.default.decode.bytes;const r=i.default.decode(e,t);t+=i.default.decode.bytes;const n=i.default.decode(e,t);t+=i.default.decode.bytes;return{metaIndexOffset:s,metaIndexSize:r,indexOffset:n,indexSize:i.default.decode(e,t)}}put(e){const t=Buffer.concat([Buffer.from(i.default.encode(e.metaIndexOffset)),Buffer.from(i.default.encode(e.metaIndexSize)),Buffer.from(i.default.encode(e.indexOffset)),Buffer.from(i.default.encode(e.indexSize))]),s=Buffer.alloc(40-t.length);this._buffer=Buffer.concat([t,s,Buffer.alloc(8)])}}t.default=a,o(a,"kEncodedLength",48)})),Me=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=l(R),s=l(r),n=l(L),o=l(W),a=l(ze);function l(e){return e&&e.__esModule?e:{default:e}}function u(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.default=class{constructor(e,t){u(this,"_closed",void 0),u(this,"_numberOfEntries",void 0),u(this,"_options",void 0),u(this,"_file",void 0),u(this,"_fileSize",void 0),u(this,"_lastKey",void 0),u(this,"_dataBlock",void 0),u(this,"_metaBlock",void 0),u(this,"_indexBlock",void 0),u(this,"_footer",void 0),u(this,"_offset",void 0),u(this,"_pendingIndexEntry",void 0),u(this,"_pendingHandle",void 0),this._file=t,this._fileSize=0,this._metaBlock=new h,this._footer=new a.default(Buffer.alloc(48)),this._numberOfEntries=0,this._offset=0,this._pendingIndexEntry=!1,this._closed=!1,this._options=e,this._dataBlock=new f(this._options),this._dataBlock.blockType="datablock",this._indexBlock=new f(this._options),this._indexBlock.blockType="indexblock",this._pendingHandle=new C.BlockHandle}async add(e,t){if((0,s.default)(!this._closed),this._numberOfEntries>0&&(0,s.default)(this._options.comparator.compare(e,this._lastKey)>0,"new key must bigger then last key"),this._pendingIndexEntry){(0,s.default)(this._dataBlock.isEmpty()),this._options.comparator.findShortestSeparator(this._lastKey,e);const t=this._pendingHandle.buffer;this._indexBlock.add(this._lastKey,new n.default(t)),this._pendingIndexEntry=!1}this._metaBlock&&this._metaBlock.addkey(e),this._lastKey=new n.default(e),this._numberOfEntries++,this._dataBlock.add(e,t),this._dataBlock.currentSizeEstimate()>this._options.blockSize&&await this.flush()}get numEntries(){return this._numberOfEntries}get fileSize(){return this._fileSize}async flush(){(0,s.default)(!this._closed),this._dataBlock.isEmpty()||((0,s.default)(!this._pendingIndexEntry),await this.writeBlock(this._dataBlock,this._pendingHandle),this._pendingIndexEntry=!0,this._metaBlock&&this._metaBlock.startBlock(this._offset))}async writeBlock(e,t){const i=e.finish(),s=C.CompressionTypes.none;await this.writeRawBlock(i,s,t),this._dataBlock.reset()}async writeRawBlock(e,t,s){s.offset=this._offset,s.size=e.size,await this.appendFile(e.buffer);const r=Buffer.alloc(C.kBlockTrailerSize);r[0]=t;const n=(0,i.default)(Buffer.concat([e.buffer,Buffer.from([t])]));r.fill(n,1,5),await this.appendFile(r),this._offset+=e.size+C.kBlockTrailerSize}async appendFile(e){await this._file.appendFile(e,{encoding:"buffer"}),this._fileSize+=e.length}async close(){if(!this._closed){const e=this._file;this._closed=!0,delete this._file;try{await e.close()}catch(e){}}}async abandon(){await this.close()}async finish(){await this.flush();const e=new C.BlockHandle,t=new C.BlockHandle,i=new C.BlockHandle;this._metaBlock&&await this.writeRawBlock(this._metaBlock.finish(),C.CompressionTypes.none,e);const s=new f(this._options);if(s.blockType="metaindexblock",this._metaBlock){let i="filter.";i+=this._options.filterPolicy.name();const r=e.buffer;s.add(new n.default(i),new n.default(r)),await this.writeBlock(s,t)}if(this._pendingIndexEntry){this._options.comparator.findShortSuccessor(this._lastKey);const e=this._pendingHandle.buffer;this._indexBlock.add(this._lastKey,new n.default(e)),this._pendingIndexEntry=!1}await this.writeBlock(this._indexBlock,i),this._footer.put({metaIndexOffset:t.offset,metaIndexSize:t.size,indexOffset:i.offset,indexSize:i.size}),await this.appendFile(this._footer.buffer),this._offset+=this._footer.buffer.length,await this.close()}};class f{constructor(e){u(this,"blockType",void 0),u(this,"_options",void 0),u(this,"_buffer",void 0),u(this,"_restarts",void 0),u(this,"_finished",void 0),u(this,"_counter",void 0),u(this,"_lastKey",void 0),this._options=e,this._buffer=Buffer.alloc(0),this._restarts=[0],this._counter=0,this._finished=!1,this._lastKey=new n.default}get buffer(){return this._buffer}reset(){this._buffer=Buffer.alloc(0),this._restarts=[0],this._counter=0,this._finished=!1,this._lastKey=new n.default}add(e,t){(0,s.default)(!this._finished),(0,s.default)(this._counter<=this._options.blockRestartInterval),(0,s.default)(0===this._buffer.length||this._options.comparator.compare(e,this._lastKey)>0);let i=0;if(this._counter<this._options.blockRestartInterval){const t=Math.min(this._lastKey.size,e.size);for(;i<t&&this._lastKey.buffer[i]===e.buffer[i];)i++}else this._restarts.push(this._buffer.length),this._counter=0;const r=e.size-i;this._buffer=Buffer.concat([this._buffer,(0,x.encodeFixed32)(i),(0,x.encodeFixed32)(r),(0,x.encodeFixed32)(t.size),e.buffer.slice(i),t.buffer]),this._lastKey=new n.default(Buffer.concat([this._lastKey.buffer.slice(0,i),e.buffer.slice(i)])),(0,s.default)(0===this._lastKey.buffer.compare(e.buffer))}isEmpty(){return 0===this._buffer.length}finish(){for(let e=0;e<this._restarts.length;e++)this._buffer=Buffer.concat([this._buffer,(0,x.encodeFixed32)(this._restarts[e])]);return this._buffer=Buffer.concat([this._buffer,(0,x.encodeFixed32)(this._restarts.length)]),this._finished=!0,new n.default(this._buffer)}currentSizeEstimate(){return this._buffer.length+this._restarts.length*C.kSizeOfUInt32+C.kSizeOfUInt32}}class h{constructor(){u(this,"_keys",void 0),u(this,"_starts",void 0),u(this,"_result",void 0),u(this,"_tempKeys",void 0),u(this,"_filterOffsets",void 0),this._keys=Buffer.alloc(0),this._starts=[],this._result=Buffer.alloc(0),this._tempKeys=[],this._filterOffsets=[]}startBlock(e){const t=Math.floor(e/h.kFilterBase);for((0,s.default)(t>=this._filterOffsets.length);t>this._filterOffsets.length;)this.generateFilter()}generateFilter(){const e=this._starts.length;if(0===e)return void this._filterOffsets.push(this._result.length);this._starts.push(this._keys.length);for(let t=0;t<e;t++)this._tempKeys[t]=new n.default(this._keys.slice(this._starts[t],this._starts[t+1]));this._filterOffsets.push(this._result.length);const t=new o.default;t.putKeys(this._tempKeys,e),this._result=Buffer.concat([this._result,t.buffer]),this._keys=Buffer.alloc(0),this._tempKeys=[],this._starts=[]}addkey(e){this._starts.push(this._keys.length),this._keys=Buffer.concat([this._keys,e.buffer])}finish(){this._starts.length>0&&this.generateFilter();const e=this._result.length;for(let e=0;e<this._filterOffsets.length;e++)this._result=Buffer.concat([this._result,(0,x.encodeFixed32)(this._filterOffsets[e])]);return this._result=Buffer.concat([this._result,(0,x.encodeFixed32)(e),Buffer.from([h.kFilterBaseLg])]),new n.default(this._result)}}u(h,"kFilterBaseLg",11),u(h,"kFilterBase",1<<h.kFilterBaseLg)})),Oe=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=n(L),s=n(r);function n(e){return e&&e.__esModule?e:{default:e}}function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.default=class{constructor(e){o(this,"blockType",void 0),o(this,"_restartPoint",void 0),o(this,"_size",void 0),o(this,"_buffer",void 0),this._buffer=e.data.buffer,this._size=e.data.size;const t=(this._size-C.kSizeOfUInt32)/C.kSizeOfUInt32;this.getNumRestarts()>t?this._size=0:this._restartPoint=this._size-(1+this.getNumRestarts())*C.kSizeOfUInt32}get buffer(){return this._buffer}get size(){return this._size}getNumRestarts(){return(0,x.decodeFixed32)(this._buffer.slice(this._size-4))}decodeEntry(e,t){const r=(0,x.decodeFixed32)(this._buffer.slice(e,e+4)),n=(0,x.decodeFixed32)(this._buffer.slice(e+4,e+8)),o=(0,x.decodeFixed32)(this._buffer.slice(e+8,e+12)),a=r+n,l=this._buffer.slice(e+12,e+12+n),u=t.buffer.slice(0,r),f=new i.default(Buffer.concat([u,l]));return(0,s.default)(f.length===a),{rawSize:12+n+o,shared:r,nonShared:n,entry:{key:f,value:new i.default(this._buffer.slice(e+12+n,e+12+n+o))}}}*restartPointIterator(){let e=this._restartPoint;for(;!(e>=this._size-4);)yield(0,x.decodeFixed32)(this._buffer.slice(e,e+4)),e+=4}*iterator(e){if(0===this.getNumRestarts())return;const t=this.restartPointIterator();let s=0,r=new i.default,n=t.next(),o=n.value;for(;!(s>=this._restartPoint);){const e=this.decodeEntry(s,r);yield e.entry,r=new i.default(e.entry.key),s+=e.rawSize,s===o&&(r=new i.default,n=t.next(),o=n.value)}}}})),Ee=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=r(F),s=r(L);function r(e){return e&&e.__esModule?e:{default:e}}function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.default=class{constructor(e,t){n(this,"_buffer",void 0),n(this,"_data",void 0),n(this,"_offset",void 0),n(this,"_size",void 0),n(this,"_policy",void 0),n(this,"_num",void 0),n(this,"_baseLg",void 0),this._buffer=t.buffer,this._policy=e,this._num=0,this._baseLg=0;const i=t.size;if(i<5)return;this._baseLg=t.buffer[t.length-1];const s=(0,x.decodeFixed32)(t.buffer.slice(i-5));s>i-5||(this._buffer=t.buffer,this._data=0,this._offset=s,this._num=(i-5-s)/4)}get size(){return this._size}get buffer(){return this._buffer}get beginningOfOffset(){let e;return e=0===this._offset&&this._size===this._buffer.length?this._buffer:this._buffer.slice(this._offset,this._size),i.default.decode(e,e.length-2)}keyMayMatch(e,t){const i=e>>this._baseLg;if(i<this._num){const e=(0,x.decodeFixed32)(this._buffer.slice(this._offset+4*i)),r=(0,x.decodeFixed32)(this._buffer.slice(this._offset+4*i+4));if(e<=r&&r<=this._offset+this._size){const i=new s.default(this._buffer.slice(this._offset+e,this._offset+r-e));return this._policy.keyMayMatch(t,i)}if(e==r)return!1}return!0}}})),Pe=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=u(L),s=u(ze),n=u(Oe),o=u(Ee),a=u(Se),l=u(r);function u(e){return e&&e.__esModule?e:{default:e}}function f(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class h{static async readBlock(e,t,s){const r={data:new i.default,cachable:!1,heapAllocated:!1},n=s.size,o=Buffer.alloc(s.size+C.kBlockTrailerSize),{bytesRead:a}=await e.read(o,0,o.length,s.offset);if(a!==s.size+C.kBlockTrailerSize)throw new Error("truncated block read");switch(o[n]){case C.CompressionTypes.none:r.data=new i.default(o.slice(0,n));break;default:throw new Error("bad block type")}return r}static async open(e,t){const i=await t.stat();if(i.size<s.default.kEncodedLength)throw new Error("file is too short to be an sstable");const r=Buffer.alloc(s.default.kEncodedLength);await t.read(r,0,r.length,i.size-s.default.kEncodedLength);const o=new s.default(r),a=await this.readBlock(t,new _e.ReadOptions,o.indexHandle),l=new n.default(a);l.blockType="indexblock";const u=new h({file:t,options:e,indexBlock:l,metaIndexHandle:o.metaIndexHandle});return await u.readMeta(o),u}constructor(e){f(this,"_file",void 0),f(this,"_cacheId",void 0),f(this,"_options",void 0),f(this,"_indexBlock",void 0),f(this,"_filterReader",void 0),this._file=e.file,this._options=e.options,this._indexBlock=e.indexBlock,this._cacheId=e.options.blockCache.newId()}async readMeta(e){if(!this._options.filterPolicy)return;const t=await h.readBlock(this._file,new _e.ReadOptions,e.metaIndexHandle),s=new n.default(t);s.blockType="metaindexblock";const r=new i.default("filter."+this._options.filterPolicy.name());for(const e of s.iterator(this._options.comparator))e.key.isEqual(r)&&await this.readFilter(e.value.buffer)}async readFilter(e){const t=C.BlockHandle.from(e),i=new _e.ReadOptions,s=await h.readBlock(this._file,i,t);this._filterReader=new o.default(this._options.filterPolicy,s.data)}async get(e){const t=C.InternalKey.from(e);for(const i of this._indexBlock.iterator(this._options.comparator)){const s=C.BlockHandle.from(i.value.buffer);if(this._filterReader&&!this._filterReader.keyMayMatch(s.offset,e));else for await(const e of this.blockIterator(this,this._options,s,"datablock")){const i=C.InternalKey.from(e.key);if(i.userKey.isEqual(t.userKey)&&i.sequence<=t.sequence)return new a.default(Promise.resolve(e))}}return a.default.createNotFound()}async*entryIterator(){for(const e of this._indexBlock.iterator(this._options.comparator)){const t=C.BlockHandle.from(e.value.buffer);yield*this.blockIterator(this,this._options,t,"datablock")}}async*blockIterator(e,t,s,r){const o=Buffer.concat([(0,x.encodeFixed64)(this._cacheId),(0,x.encodeFixed64)(s.offset)]);let a=this._options.blockCache.get(o);if(!a){const e=Buffer.alloc(s.size),{bytesRead:t}=await this._file.read(e,0,e.length,s.offset);(0,l.default)(t===e.length);const u={data:new i.default(e)};a=new n.default(u),r&&(a.blockType=r),this._options.blockCache.set(o,a)}yield*a.iterator(t.comparator)}}t.default=h})),Re=c((function(e,t){t.__esModule=!0,t.TableCache=void 0;var i=o(Se),s=o(Pe),r=o(ye),n=o(ge);function o(e){return e&&e.__esModule?e:{default:e}}function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.TableCache=class{constructor(e,t,i){a(this,"_env",void 0),a(this,"_dbpath",void 0),a(this,"_options",void 0),a(this,"_cache",void 0),this._env=t.env,this._dbpath=e,this._options=t,this._cache=new n.default({max:i,async dispose(e,t){try{await t.file.close()}catch(e){}}})}async get(e,t,i,s,r,n){let o=await this.findTable(t,i);if(await o.ok()){const e=(await o.promise).table;o=await e.get(s)}if(await o.ok()){const{key:e,value:t}=await o.promise;n(r,e,t)}return o}async findTable(e,t){let r=new i.default;const n=this._cache.get(e);if(n)r=new i.default(Promise.resolve(n));else{const t=(0,Fe.getTableFilename)(this._dbpath,e);r=new i.default(this._env.open(t,"r+"));const n={};await r.ok()&&(n.file=await r.promise,r=new i.default(s.default.open(this._options,n.file))),await r.ok()&&(n.table=await r.promise,this._cache.set(e,n),r=new i.default(Promise.resolve(n)))}return r}async*entryIterator(e,t,i){const s=await this.findTable(t,i);if(!await s.ok())throw(0,G.Log)(this._options.infoLog,`Open Table file(${t}) fail.`),new Error(`Open Table file(${t}) fail.`);{const e=await s.promise;yield*r.default.wrap(e.table.entryIterator(),async()=>{await e.file.close()})}}}})),Ve=c((function(e,t){function i(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.__esModule=!0,t.SnapshotList=t.Snapshot=void 0;class s{constructor(e){i(this,"_sequenceNumber",void 0),i(this,"next",void 0),i(this,"prev",void 0),this._sequenceNumber=e}get sequenceNumber(){return this._sequenceNumber}}t.Snapshot=s;t.SnapshotList=class{oldest(){return new s(new C.SequenceNumber)}}})),qe=c((function(e,t){function i(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.__esModule=!0,t.WriterQueue=t.Writer=void 0;t.Writer=class{constructor(){i(this,"batch",void 0),i(this,"sync",!1),i(this,"done",!1),i(this,"resolve",void 0)}signal(){this.resolve&&this.resolve(),delete this.resolve}wait(){return delete this.resolve,new Promise(e=>this.resolve=e)}};t.WriterQueue=class{constructor(){i(this,"list",[])}push(e){this.list.push(e)}front(){return this.list[0]}popFront(){this.list.shift()}get length(){return this.list.length}*iterator(e=0){for(let t=e;t<this.list.length;t++)yield this.list[t]}}})),De=c((function(e){e.exports=["SIGABRT","SIGALRM","SIGHUP","SIGINT","SIGTERM"],"win32"!==process.platform&&e.exports.push("SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),"linux"===process.platform&&e.exports.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT","SIGUNUSED")})),Ue=/^win/i.test(process.platform),Ae=l;"function"!=typeof Ae&&(Ae=Ae.EventEmitter),process.__signal_exit_emitter__?me=process.__signal_exit_emitter__:((me=process.__signal_exit_emitter__=new Ae).count=0,me.emitted={}),me.infinite||(me.setMaxListeners(1/0),me.infinite=!0);var We=function(e,t){r.equal(typeof e,"function","a callback must be provided for exit handler"),!1===Ze&&Je();var i="exit";t&&t.alwaysLast&&(i="afterexit");return me.on(i,e),function(){me.removeListener(i,e),0===me.listeners("exit").length&&0===me.listeners("afterexit").length&&je()}},Ge=je;function je(){Ze&&(Ze=!1,De.forEach((function(e){try{process.removeListener(e,$e[e])}catch(e){}})),process.emit=et,process.reallyExit=Xe,me.count-=1)}function He(e,t,i){me.emitted[e]||(me.emitted[e]=!0,me.emit(e,t,i))}var $e={};De.forEach((function(e){$e[e]=function(){process.listeners(e).length===me.count&&(je(),He("exit",null,e),He("afterexit",null,e),Ue&&"SIGHUP"===e&&(e="SIGINT"),process.kill(process.pid,e))}}));var Qe=Je,Ze=!1;function Je(){Ze||(Ze=!0,me.count+=1,De=De.filter((function(e){try{return process.on(e,$e[e]),!0}catch(e){return!1}})),process.emit=tt,process.reallyExit=Ye)}var Xe=process.reallyExit;function Ye(e){process.exitCode=e||0,He("exit",process.exitCode,null),He("afterexit",process.exitCode,null),Xe.call(process,process.exitCode)}var et=process.emit;function tt(e,t){if("exit"===e){void 0!==t&&(process.exitCode=t);var i=et.apply(this,arguments);return He("exit",process.exitCode,null),He("afterexit",process.exitCode,null),i}return et.apply(this,arguments)}We.unload=Ge,We.signals=function(){return De},We.load=Qe;var it=c((function(e,t){t.__esModule=!0,t.Lockfile=void 0;var i,s=(i=We)&&i.__esModule?i:{default:i};function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.Lockfile=class{constructor(e,t){r(this,"filetime",void 0),r(this,"filename",void 0),r(this,"options",void 0),r(this,"refreshLockTimer",void 0),r(this,"_locked",!1),r(this,"stale",void 0),this.filename=e,this.options=t,this.filetime="win32"===t.env.platform()?"mtime":"ctime",this.stale=t.lockfileStale,(0,s.default)(()=>{this.options.env.unlinkSync(this.filename)})}get locked(){return this._locked}async unlock(){await this.options.env.unlink(this.filename),this._locked=!1,clearInterval(this.refreshLockTimer)}async waitUntilExpire(e=Date.now()){try{const t=await this.options.env.open(this.filename,"r");try{const e=await t.stat(),i=new Date(e[this.filetime]).getTime();if(Date.now()>i+this.stale+1e3)return!0}catch(e){}finally{await t.close()}return!(Date.now()>e+2*this.stale+1e3)&&(await new Promise(e=>setTimeout(e,this.stale/2)),await this.waitUntilExpire(e))}catch(e){return!1}}async waitUntilOk(){try{const e=await this.options.env.open(this.filename,"r");await e.close();return await this.waitUntilExpire()}catch(e){return"ENOENT"===e.code}}async writeSomething(){try{await this.options.env.writeFile(this.filename,""),this._locked=!0}catch(e){}}async lock(){if(!await this.waitUntilOk())throw new Error("Lock fail");await this.writeSomething(),this.refreshLockTimer=setInterval(()=>this.writeSomething(),this.stale/2)}}})),st=c((function(e,t){t.__esModule=!0,t.default=void 0;var i=g(s),n=g(r),o=g(T),a=g(q),l=g(ye),u=g(L),f=g(Ie),h=g(we),c=g(xe),d=g(Se),p=g(Me),m=g(Ce),b=g(Ne);function g(e){return e&&e.__esModule?e:{default:e}}function _(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.default=class{constructor(e,t=new _e.Options){_(this,"writers",new qe.WriterQueue),_(this,"tmpBatch",new Ke.WriteBatch),_(this,"_internalKeyComparator",void 0),_(this,"_backgroundCompactionScheduled",void 0),_(this,"_dbpath",void 0),_(this,"_sn",void 0),_(this,"_ok",!1),_(this,"_status",void 0),_(this,"_log",void 0),_(this,"_logFileNumber",0),_(this,"_memtable",void 0),_(this,"_immtable",void 0),_(this,"_versionSet",void 0),_(this,"_manualCompaction",void 0),_(this,"_bgError",void 0),_(this,"pendingOutputs",void 0),_(this,"snapshots",void 0),_(this,"_stats",void 0),_(this,"_options",void 0),_(this,"_tableCache",void 0),_(this,"lockfile",void 0),this._backgroundCompactionScheduled=!1,this._internalKeyComparator=new C.InternalKeyComparator(new D.BytewiseComparator),this._dbpath=e,this._sn=new C.SequenceNumber(0),this.pendingOutputs=new Set,this._stats=Array.from({length:C.Config.kNumLevels},()=>new ke.CompactionStats),t.comparator=this._internalKeyComparator,this._options=t,this.lockfile=new it.Lockfile((0,Fe.getLockFilename)(e),t),this._tableCache=new Re.TableCache(e,t,t.maxOpenFiles-10),this._versionSet=new f.default(this._dbpath,t,this._tableCache,this._internalKeyComparator),this._status=new d.default(this.recoverWrapper())}get userComparator(){return this._internalKeyComparator.userComparator}async shouldInit(){const e=(0,Fe.getCurrentFilename)(this._dbpath);let t=!1;try{await this._options.env.access(this._dbpath)}catch(e){t=!0,await this._options.env.mkdir(this._dbpath)}await this.lockfile.lock();try{await this._options.env.access(e)}catch(e){t=!0}return t}async initVersionEdit(){const e=new h.default;e.comparator=this._internalKeyComparator.userComparator.getName(),e.logNumber=0,e.nextFileNumber=2,e.lastSequence=0;const t=new a.default(await this._options.env.open((0,Fe.getManifestFilename)(this._dbpath,1),"a"));await t.addRecord(c.default.add(e)),await t.close(),await this._options.env.writeFile((0,Fe.getCurrentFilename)(this._dbpath),"MANIFEST-000001\n")}async recoverWrapper(){try{let e=new d.default(this.recover()),t={},i=!1;if(!await e.ok())throw e.error;{const s=await e.promise;t=s.edit,i=s.saveManifest}if(await e.ok()&&!this._memtable){const e=this._versionSet.getNextFileNumber();t.logNumber=e,this._logFileNumber=e,this._log&&(await this._log.close(),delete this._log),this._log=new a.default(await this._options.env.open((0,Fe.getLogFilename)(this._dbpath,e),"a")),this._memtable=new o.default(this._internalKeyComparator),this._memtable.ref()}if(await e.ok()&&i&&(t.prevLogNumber=0,t.logNumber=this._logFileNumber,e=await this._versionSet.logAndApply(t)),await e.ok()&&(await this.deleteObsoleteFiles(),await this.maybeScheduleCompaction(),(0,n.default)(!!this._memtable)),!await e.ok())throw e.error}catch(e){throw this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG DB recover fail"),e}}async recover(){const e={saveManifest:!1,edit:new h.default};if(await this.shouldInit())await this.initVersionEdit();else try{await this._options.env.rename((0,Fe.getInfoLogFilename)(this._dbpath),(0,Fe.getOldInfoLogFilename)(this._dbpath))}catch(e){}const t=await this._options.env.open((0,Fe.getInfoLogFilename)(this._dbpath),"a+");this._options.infoLog=new G.InfoLog(t);const i=await this._versionSet.recover();"boolean"==typeof i.saveManifest&&(e.saveManifest=i.saveManifest);const s=new C.SequenceNumber(0),r=this._versionSet.logNumber,n=this._versionSet.prevLogNumber,o=(await this._options.env.readdir(this._dbpath)).reduce((e,t)=>(t.isFile()&&e.push(t.name),e),[]),a=new Set;this._versionSet.addLiveFiles(a);let l=[];for(const e of o){const t=(0,Fe.parseFilename)(e);t.isInternalFile&&(a.delete(t.number),t.type==C.FileType.kLogFile&&(t.number>=r||t.number===n)&&l.push(t.number))}if(a.size>0)throw new Error(a.size+" missing files; e.g.");const u=e.edit;l=l.sort();for(let t=0;t<l.length;t++){const i=await this.recoverLogFile(l[t],t===l.length-1,u,s);"boolean"==typeof i.saveManifest&&(e.saveManifest=i.saveManifest),this._versionSet.markFileNumberUsed(l[t])}return this._versionSet.lastSequence<s.value&&(this._versionSet.lastSequence=s.value),e}async recoverLogFile(e,t,i,s){const r={};let n=new d.default;const a=(0,Fe.getLogFilename)(this._dbpath,e),l=new m.default(await this._options.env.open(a,"r"));(0,G.Log)(this._options.infoLog,"Recovering log #"+e);let u=null;for await(const e of l.iterator()){if(e.size<12){(0,G.Log)(this._options.infoLog,` ${a} log record too small: dropping ${e.size} bytes`);continue}const t=new Ke.WriteBatch;Ke.WriteBatchInternal.setContents(t,e.buffer),u||(u=new o.default(this._internalKeyComparator),u.ref()),Ke.WriteBatchInternal.insert(t,u);const l=Ke.WriteBatchInternal.getSequence(t).value+Ke.WriteBatchInternal.getCount(t)-1;if(l>s.value&&(s.value=l),u.size>this._options.writeBufferSize&&(r.saveManifest=!0,n=await this.writeLevel0Table(u,i),u.unref(),u=null,!await n.ok()))break}return this._options.reuseLogs,u&&(await n.ok()&&(r.saveManifest=!0,n=await this.writeLevel0Table(u,i)),u.unref()),r}async ok(){if(await this._status.ok())return this._ok=!0,!0;throw this._ok=!1,this._status.error}async destroy(){this.lockfile.unlock()}async*iterator(e=new _e.IteratorOptions){this._ok||await this.ok();const t=new u.default(e.start),i=e.snapshot?new Ve.Snapshot(e.snapshot).sequenceNumber:new C.SequenceNumber(this._versionSet.lastSequence),s=new C.LookupKey(t,i),r=[];this._memtable.ref(),r.push(l.default.wrap(l.default.makeAsync(this._memtable.iterator()),()=>{this._memtable.unref()})),this._immtable&&(this._immtable.ref(),r.push(l.default.wrap(l.default.makeAsync(this._immtable.iterator()),()=>{this._immtable.unref()})));const n=this._versionSet.current,o=this._versionSet.tableCache;n.ref();for(let e=0;e<C.Config.kNumLevels;e++){const i=n.files[e];if(i.length>0)for(const e of i){if(this.userComparator.compare(t,e.largest.userKey)>0)continue;const i=await o.findTable(e.number,e.fileSize);if(await i.ok()){e.refs++;const t=await i.promise;r.push(l.default.wrap(t.table.entryIterator(),async()=>{e.refs--,n.unref(),await t.file.close()}))}}}const a=new b.default(this._internalKeyComparator,r,r.length);for await(const e of a.iterator()){const t=C.InternalKey.from(e.key),i=t.userKey;if(this.userComparator.compare(i,s.userKey)>0){if(s.userKey=i,t.type===C.ValueType.kTypeDeletion)continue;yield{key:i.buffer,value:e.value.buffer}}}}async get(e,t=new _e.ReadOptions){this._ok||await this.ok();const i=new u.default(e),s=t.snapshot?new Ve.Snapshot(t.snapshot).sequenceNumber:new C.SequenceNumber(this._versionSet.lastSequence),r=new C.LookupKey(i,s),n=this._versionSet.current;this._memtable.ref(),this._immtable&&this._immtable.ref(),n.ref();let o=!1;const a={};let l=void 0;for(;;){const e=this._memtable.get(r);if(e){if(e.type!==C.ValueType.kTypeValue)break;l=e.value.buffer}if(!l&&this._immtable){const e=this._immtable.get(r);if(e){if(e.type!==C.ValueType.kTypeValue)break;l=e.value.buffer}}if(!l){const e=await n.get(r,a);o=!0,await e.ok()&&(l=await e.promise)}break}return o&&n.updateStats(a)&&await this.maybeScheduleCompaction(),this._memtable.unref(),this._immtable&&this._immtable.unref(),n.unref(),l}put(e,t,i=new _e.WriteOptions){const s=new Ke.WriteBatch;return s.put(e,t),this.write(i,s)}del(e,t=new _e.WriteOptions){const i=new Ke.WriteBatch;return i.del(e),this.write(t,i)}batch(e,t=new _e.WriteOptions){return this.write(t,e)}async write(e,t){this._ok||await this.ok();const i=new qe.Writer;for(i.batch=t,this.writers.push(i);this.writers.front()!==i&&!i.done;)await i.wait();if(i.done)return;const s=await this.makeRoomForWrite(!i.batch);let r=i;if(await s.ok()&&i.batch){let e=this._versionSet.lastSequence;const[t,i]=this.buildBatchGroup();r=t,Ke.WriteBatchInternal.setSequence(i,e+1),e+=Ke.WriteBatchInternal.getCount(i),await this._log.addRecord(new u.default(Ke.WriteBatchInternal.getContents(i))),Ke.WriteBatchInternal.insert(i,this._memtable),i===this.tmpBatch&&this.tmpBatch.clear(),this._versionSet.lastSequence=e}for(;;){const e=this.writers.front();if(this.writers.popFront(),e&&e!==i&&(e.done=!0,e.signal()),e===r)break}if(this.writers.length>0){const e=this.writers.front();e&&e.signal()}}buildBatchGroup(){const e=this.writers.front();if(!e)throw new Error("writer is empty");let t=e.batch;if(!t)throw new Error("first batch is empty");let i=Ke.WriteBatchInternal.byteSize(t),s=1<<20;i<=131072&&(s=i+131072);let r=e;for(const o of this.writers.iterator(1)){if(o.sync&&!e.sync)break;if(o.batch){if(i+=Ke.WriteBatchInternal.byteSize(o.batch),i>s)break;t===e.batch&&(t=this.tmpBatch,(0,n.default)(0===Ke.WriteBatchInternal.getCount(t)),Ke.WriteBatchInternal.append(t,e.batch)),Ke.WriteBatchInternal.append(t,o.batch)}r=o}return[r,t]}async makeRoomForWrite(e){let t=!e,i=new d.default;for(;;){if(this._bgError){i=this._bgError;break}if(t&&this._versionSet.getNumLevelFiles(0)>=C.Config.kL0SlowdownWritesTrigger)this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG level0 files >= slowdown trigger, wait 1s."),await new Promise(e=>setTimeout(e,1e3)),t=!1;else{if(!e&&this._memtable.size<=this._options.writeBufferSize)break;if(this._immtable)(0,G.Log)(this._options.infoLog,"Current memtable full; waiting...");else if(this._versionSet.getNumLevelFiles(0)>=C.Config.kL0StopWritesTrigger)(0,G.Log)(this._options.infoLog,"Too many L0 files; waiting...");else{(0,G.Log)(this._options.infoLog,"Attempt to switch to a new memtable and trigger compaction of old"),(0,n.default)(0===this._versionSet.prevLogNumber);const t=this._versionSet.getNextFileNumber();this._log&&(await this._log.close(),delete this._log),this._log=new a.default(await this._options.env.open((0,Fe.getLogFilename)(this._dbpath,t),"a")),this._immtable=this._memtable,this._memtable=new o.default(this._internalKeyComparator),this._memtable.ref(),this._logFileNumber=t,e=!1,await this.maybeScheduleCompaction()}}}return i}async maybeScheduleCompaction(){this._options.debug&&(0,G.Log)(this._options.infoLog,`DEBUG !this._immtable=${!this._immtable} !this._manualCompaction=${!this._manualCompaction} !this._versionSet.needsCompaction()=${!this._versionSet.needsCompaction()}`),this._backgroundCompactionScheduled?(0,G.Log)(this._options.infoLog,"Already scheduled"):this._bgError&&!await this._bgError.ok()?(0,G.Log)(this._options.infoLog,"Already got an error; no more changes"):this._immtable||this._manualCompaction||this._versionSet.needsCompaction()?(this._backgroundCompactionScheduled=!0,(0,G.Log)(this._options.infoLog,"Background Compaction Scheduled"),await this.backgroundCall()):(0,G.Log)(this._options.infoLog,"No work to be done")}async backgroundCall(){(0,n.default)(this._backgroundCompactionScheduled),await this.backgroundCompaction(),this._backgroundCompactionScheduled=!1,await this.maybeScheduleCompaction()}async backgroundCompaction(){if(this._immtable)return(0,G.Log)(this._options.infoLog,"backgroundCompaction Compact MemTable and return"),void await this.compactMemTable();let e,t=new C.InternalKey;if(this._manualCompaction){const i=this._manualCompaction;e=this._versionSet.compactRange(i.level,i.begin,i.end),i.done=!e,e&&(t=e.inputs[0][e.numInputFiles(0)-1].largest),this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG Manual compaction ...")}else e=this._versionSet.pickCompaction();let i=new d.default;if(e)if(!this._manualCompaction&&e.isTrivialMove()){(0,G.Log)(this._options.infoLog,"backgroundCompaction isTrivialMove"),(0,n.default)(1===e.numInputFiles(0));const t=e.inputs[0][0];e.edit.deleteFile(e.level,t.number),e.edit.addFile(e.level+1,t.number,t.fileSize,t.smallest,t.largest),i=await this._versionSet.logAndApply(e.edit)}else{(0,G.Log)(this._options.infoLog,"backgroundCompaction doCompactionWork");const t=new ke.CompactionState(e),i=await this.doCompactionWork(t);await i.ok()||await this.recordBackgroundError(i),await this.cleanupCompaction(t),e.releaseInputs(),await this.deleteObsoleteFiles()}else(0,G.Log)(this._options.infoLog,"backgroundCompaction no compaction");if(await i.ok()?(0,G.Log)(this._options.infoLog,"Compaction success..."):(0,G.Log)(this._options.infoLog,"Compaction error..."),this._manualCompaction){const e=this._manualCompaction;await i.ok()||(e.done=!0),e.done||(e.tmpStorage=t,e.begin=e.tmpStorage),delete this._manualCompaction}}async doCompactionWork(e){const t=this._options.env.now();let i=0;(0,G.Log)(this._options.infoLog,"Compacting files..."),(0,n.default)(this._versionSet.getNumLevelFiles(e.compaction.level)>0),(0,n.default)(!e.builder),(0,n.default)(!e.outfile),this.snapshots?e.smallestSnapshot=this.snapshots.oldest().sequenceNumber.value:e.smallestSnapshot=this._versionSet.lastSequence;let s=new d.default;const r=new C.ParsedInternalKey,o=new u.default;let a=!1,l=C.InternalKey.kMaxSequenceNumber;this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG doCompactionWork before make input iterator");for await(const t of this._versionSet.makeInputIterator(e.compaction)){if(this._immtable){const e=this._options.env.now();await this.compactMemTable(),i+=this._options.env.now()-e}const n=t.key;if(e.compaction.shouldStopBefore(n)&&e.builder&&(s=await this.finishCompactionOutputFile(e,s),!await s.ok())){(0,G.Log)(this._options.infoLog,"Break because finishCompactionOutputFile fail "+(s.message()||"-"));break}let u=!1;if((0,C.parseInternalKey)(n,r)?(a&&0===this.userComparator.compare(r.userKey,o)||(o.buffer=r.userKey.buffer,a=!0,l=C.InternalKey.kMaxSequenceNumber),(l.value<=e.smallestSnapshot||r.valueType===C.ValueType.kTypeDeletion&&r.sn.value<=e.smallestSnapshot&&e.compaction.isBaseLevelForKey(r.userKey))&&(u=!0),l=r.sn):(o.clear(),a=!1,l=C.InternalKey.kMaxSequenceNumber),!u){if(!e.builder&&(s=await this.openCompactionOutputFile(e),!await s.ok())){(0,G.Log)(this._options.infoLog,"Break because openCompactionOutputFile fail "+(s.message()||"-"));break}if(0==e.builder.numEntries&&e.currentOutput().smallest.decodeFrom(n),e.currentOutput().largest.decodeFrom(n),await e.builder.add(n,t.value),e.builder.fileSize>=e.compaction.maxOutputFilesize&&(s=await this.finishCompactionOutputFile(e,new d.default),!await s.ok())){(0,G.Log)(this._options.infoLog,"Break because finishCompactionOutputFile2 fail "+(s.message()||"-"));break}}}await s.ok()&&e.builder&&(s=await this.finishCompactionOutputFile(e,s));const f=new ke.CompactionStats;f.times=this._options.env.now()-t-i;for(let t=0;t<2;t++)for(let i=0;i<e.compaction.numInputFiles(t);i++)f.bytesRead+=e.compaction.inputs[t][i].fileSize;for(let t=0;t<e.outputs.length;t++)f.bytesWritten+=e.outputs[t].fileSize;return this._stats[e.compaction.level+1].add(f),await s.ok()&&(s=await this.installCompactionResults(e)),(0,G.Log)(this._options.infoLog,"compacted to: "+this._versionSet.getLevelSummary()),s}async compactMemTable(){(0,n.default)(!!this._immtable);const e=new h.default,t=this._versionSet.current;t.ref();let i=await this.writeLevel0Table(this._immtable,e,t);t.unref(),await i.ok()&&(e.prevLogNumber=0,e.logNumber=this._logFileNumber,i=await this._versionSet.logAndApply(e)),await i.ok()?((0,n.default)(!!this._immtable),this._immtable.unref(),delete this._immtable,await this.deleteObsoleteFiles()):this.recordBackgroundError(i)}async writeLevel0Table(e,t,i){if(0===e.size)return new d.default(Promise.resolve());const s=this._options.env.now(),r=new ve.FileMetaData;r.fileSize=0,r.number=this._versionSet.getNextFileNumber(),r.largest=new C.InternalKey,this.pendingOutputs.add(r.number),(0,G.Log)(this._options.infoLog,`Level-0 table #${r.number}: started`);const o=(0,Fe.getTableFilename)(this._dbpath,r.number);let a=new d.default(this._options.env.open(o,"a+"));if(!await a.ok())return a;const l=new p.default(this._options,await a.promise);for(const t of e.iterator())r.smallest||(r.smallest=C.InternalKey.from(t.key)),r.largest.decodeFrom(t.key),await l.add(t.key,t.value);if(a=new d.default(l.finish()),!await a.ok())return a;r.fileSize=l.fileSize,(0,n.default)(r.fileSize>0),(0,G.Log)(this._options.infoLog,`Level-0 table #${r.number}: ${r.fileSize} bytes ${await a.ok()?"status ok":"status error"}`),this.pendingOutputs.delete(r.number);let u=0;if(await a.ok()&&r.fileSize>0){const e=r.smallest.userKey,s=r.largest.userKey;i&&(u=i.pickLevelForMemTableOutput(e,s),(0,G.Log)(this._options.infoLog,`Pick level=${u} for imm output`)),t.addFile(u,r.number,r.fileSize,r.smallest,r.largest)}const f=new ke.CompactionStats;return f.times=this._options.env.now()-s,f.bytesWritten=r.fileSize,this._stats[u].add(f),a}async openCompactionOutputFile(e){(0,n.default)(!!e),(0,n.default)(!e.builder);const t=this._versionSet.getNextFileNumber();this.pendingOutputs.add(t);const i={};i.number=t,i.smallest=new C.InternalKey,i.largest=new C.InternalKey,e.outputs.push(i);const s=(0,Fe.getTableFilename)(this._dbpath,t);(0,G.Log)(this._options.infoLog,"Compaction output file number is "+t);const r=new d.default(this._options.env.open(s,"a+"));return await r.ok()?(e.outfile=await r.promise,e.builder=new p.default(this._options,e.outfile),this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG open file success")):this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG open file error "+(r.message||"")),r}async installCompactionResults(e){(0,G.Log)(this._options.infoLog,`Compacted ${e.compaction.numInputFiles(0)}@${e.compaction.level} + ${e.compaction.numInputFiles(1)}@${e.compaction.level+1} files => ${e.totalBytes} bytes"`),e.compaction.addInputDeletions(e.compaction.edit);const t=e.compaction.level;this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG compact.outputs.length="+e.outputs.length);for(let i=0;i<e.outputs.length;i++){const s=e.outputs[i];e.compaction.edit.addFile(t+1,s.number,s.fileSize,s.smallest,s.largest)}this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG installCompactionResults logAndApply starting...");const i=await this._versionSet.logAndApply(e.compaction.edit);return await i.ok()?this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG installCompactionResults success"):this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG installCompactionResults fail"),i}async compactRange(e,t){this._ok||await this.ok();const i=new u.default(e),s=new u.default(t);let r=1;const n=this._versionSet._current;for(let e=0;e<C.Config.kNumLevels;e++)n.overlapInLevel(e,i,s)&&(r=e);await this.manualCompactMemTable();for(let e=0;e<r;e++)await this.manualCompactRangeWithLevel(e,i,s)}async manualCompactRangeWithLevel(e,t,i){this._options.debug&&(0,G.Log)(this._options.infoLog,`DEBUG manualCompactRangeWithLevel ${e}...`),(0,n.default)(e>=0),(0,n.default)(e+1<C.Config.kNumLevels);let s=new C.InternalKey,r=new C.InternalKey;const o={};for(o.level=e,o.done=!1,t?(s=new C.InternalKey(t,C.InternalKey.kMaxSequenceNumber,C.kValueTypeForSeek),o.begin=s):delete o.begin,i?(r=new C.InternalKey(i,new C.SequenceNumber(0),C.ValueType.kTypeValue),o.end=r):delete o.end;!o.done;)this._manualCompaction?this._options.debug&&(0,G.Log)(this._options.infoLog,"DEBUG Running either my compaction or another compaction."):(this._manualCompaction=o,await this.maybeScheduleCompaction());this._manualCompaction===o&&delete this._manualCompaction}async manualCompactMemTable(){await this.write(new _e.WriteOptions)}async recordBackgroundError(e){(0,G.Log)(this._options.infoLog,e.message()||"recordBackgroundError"),this._bgError=e}async cleanupCompaction(e){e.builder?(await e.builder.abandon(),delete e.builder):(0,n.default)(!e.outfile),delete e.outfile;for(let t=0;t<e.outputs.length;t++){const i=e.outputs[t];this.pendingOutputs.delete(i.number)}}async deleteObsoleteFiles(){const e=this.pendingOutputs;this._versionSet.addLiveFiles(e);const t=(await this._options.env.readdir(this._dbpath)).reduce((e,t)=>(t.isFile()&&e.push(t.name),e),[]),s=[];for(const i of t){const t=(0,Fe.parseFilename)(i),r=t.number,n=t.type;if(t.isInternalFile){let t=!0;switch(n){case C.FileType.kLogFile:t=r>=this._versionSet.logNumber||r===this._versionSet.prevLogNumber;break;case C.FileType.kDescriptorFile:t=r>=this._versionSet.manifestFileNumber;break;case C.FileType.kTableFile:case C.FileType.kTempFile:t=e.has(r);break;case C.FileType.kCurrentFile:case C.FileType.kDBLockFile:case C.FileType.kInfoLogFile:t=!0}t||(s.push(i),C.FileType.kTableFile,(0,G.Log)(this._options.infoLog,`Delete type=${n} #${r}`))}}for(const e of s)await this._options.env.unlink(i.default.resolve(this._dbpath,e))}async finishCompactionOutputFile(e,t){let i=new d.default;(0,n.default)(!!e),(0,n.default)(!!e.outfile),(0,n.default)(!!e.builder);const s=e.currentOutput().number;(0,n.default)(0!==s);const r=e.builder.numEntries;await t.ok()?(i=new d.default(e.builder.finish()),await i.ok()):await e.builder.abandon();const o=e.builder.fileSize;return e.currentOutput().fileSize=o,e.totalBytes+=o,delete e.builder,delete e.outfile,r>0&&(i=new d.default(this._options.env.access((0,Fe.getTableFilename)(this._dbpath,s))),await i.ok()&&(0,G.Log)(this._options.infoLog,`Generated table #${s}@${e.compaction.level}: ${r} keys, ${o} bytes`)),i}}})),rt=h(c((function(e,t){t.__esModule=!0,t.IteratorOptions=t.WriteOptions=t.ReadOptions=t.Options=t.WriteBatch=t.Database=void 0;var i,s=(i=st)&&i.__esModule?i:{default:i};t.Database=s.default,t.WriteBatch=Ke.WriteBatch,t.Options=_e.Options,t.ReadOptions=_e.ReadOptions,t.WriteOptions=_e.WriteOptions,t.IteratorOptions=_e.IteratorOptions})));class nt{constructor(e){u(this,"options",void 0),u(this,"dbCache",void 0),this.options=e,this.dbCache=new Map}getDB(e){if(!this.dbCache.has(e)){const t=new rt.Database(s.resolve(process.cwd(),this.options.dbpath,"./"+e));this.dbCache.set(e,t)}return this.dbCache.get(e)}async destroy(){for(const e of this.dbCache)await e[1].destroy()}}var ot=c((function(e,t){t.__esModule=!0,t.BootBuffer=t.ReadState=t.DynamicTotalSize=t.ValueType=t.kFloatRange=t.kDoubleMaxDigits=t.kFloatMaxDigits=t.kUInt8MaxValue=t.kUInt16MaxValue=t.kUInt32MaxValue=t.kTmpBufferSize=void 0;var i=n(F),s=n(r);function n(e){return e&&e.__esModule?e:{default:e}}function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}t.kTmpBufferSize=4096;t.kUInt32MaxValue=4294967295;t.kUInt16MaxValue=65535;t.kUInt8MaxValue=16;t.kFloatMaxDigits=7;t.kDoubleMaxDigits=16;const a=[12e-39,34e37];let l,u;t.kFloatRange=a,t.ValueType=l,function(e){e[e.buffer=0]="buffer",e[e.string=1]="string",e[e.uint8=2]="uint8",e[e.uint16=3]="uint16",e[e.uint32=4]="uint32",e[e.bigint=5]="bigint",e[e.float=6]="float",e[e.double=7]="double",e[e.boolean=8]="boolean",e[e.json=9]="json"}(l||(t.ValueType=l={})),t.DynamicTotalSize=u,function(e){e[e.dynamic=0]="dynamic",e[e.fixed=1]="fixed"}(u||(t.DynamicTotalSize=u={}));class f{constructor(){o(this,"lastType",-1),o(this,"lastKeyLengthRead",!1),o(this,"lastValueLengthRead",!1),o(this,"lastKeyRead",!1),o(this,"lastValueRead",!1),o(this,"lastKeyLength",0),o(this,"lastValueLength",0),o(this,"lastKeyBuf",Buffer.allocUnsafe(0)),o(this,"lastKeyBufUsedSpace",0),o(this,"lastValueBuf",Buffer.allocUnsafe(0)),o(this,"lastValueBufUsedSpace",0)}}t.ReadState=f;class h{static async*read(e){let t={};t=Buffer.isBuffer(e)?async function*(e){yield e}(e):e;const r=Buffer.allocUnsafe(4096);let n=0,o=new f;for await(const e of t){let t=e;n>0&&(t=Buffer.concat([r.slice(0,n),t]),n=0);let l=0;for(;l<t.length;){const e=l>0?t.slice(l):t,u=4096-n;function a(){r.fill(e,n),l+=4096-n,n+=Math.max(e.length,u),(0,s.default)(4096-n>=0)}if(-1!==o.lastType)if(o.lastKeyLengthRead)if(o.lastValueLengthRead){if(!o.lastKeyRead){if(0===o.lastKeyLength){o.lastKeyRead=!0;continue}if(o.lastKeyBufUsedSpace<o.lastKeyLength){e.length>=o.lastKeyLength?(o.lastKeyBuf.fill(e),o.lastKeyBufUsedSpace=o.lastKeyLength,l+=o.lastKeyLength):a(),o.lastKeyRead=!0;continue}}if(!o.lastValueRead)if(0===o.lastValueLength)yield{type:o.lastType,key:o.lastKeyBuf.toString(),value:h.parseValue(o.lastValueBuf,o.lastType)},o=new f;else if(o.lastValueBufUsedSpace<o.lastValueLength){const e=o.lastValueBuf.length-o.lastValueBufUsedSpace;o.lastValueBuf.fill(t.slice(l),o.lastValueBufUsedSpace),l+=e,o.lastValueBufUsedSpace+=t.length,o.lastValueBufUsedSpace>=o.lastValueBuf.length&&(yield{type:o.lastType,key:o.lastKeyBuf.toString(),value:h.parseValue(o.lastValueBuf,o.lastType)},o=new f)}}else try{o.lastValueLength=i.default.decode(e),o.lastValueLengthRead=!0,o.lastValueBuf=Buffer.allocUnsafe(o.lastValueLength),o.lastValueBufUsedSpace=0,l+=i.default.decode.bytes}catch(e){a()}else try{o.lastKeyLength=i.default.decode(e),o.lastKeyLengthRead=!0,o.lastKeyBuf=Buffer.allocUnsafe(o.lastKeyLength),o.lastKeyBufUsedSpace=0,l+=i.default.decode.bytes}catch(e){a()}else try{o.lastType=i.default.decode(e),l+=i.default.decode.bytes}catch(e){a()}}}}static parseValue(e,t){let i=0;switch(t){case l.buffer:return e;case l.string:return e.toString();case l.boolean:return 1===e[0];case l.bigint:return e.readBigUInt64LE();case l.uint8:return e.readUInt8(0);case l.uint16:return e.readUInt16LE(0);case l.uint32:return e.readUInt32LE(0);case l.float:return i=e.readFloatLE(0),i%1==0?i:parseFloat(i.toFixed(7));case l.double:return i=e.readDoubleLE(0),i%1==0?i:parseFloat(i.toFixed(16));case l.json:return JSON.parse(e.toString());default:return e}}static addEntry(e,t){let r=0,n=-1,o=Buffer.allocUnsafe(8);if("boolean"==typeof t)n=l.boolean,o.writeUInt8(t?1:0,0),r=1;else if("bigint"==typeof t)n=l.bigint,o.writeBigUInt64LE(t),r=8;else if(Buffer.isBuffer(t))n=l.buffer,o=t,r=t.length;else if("string"==typeof t)n=l.string,o=Buffer.from(t),r=o.length;else if("number"==typeof t&&Number(t)===t)if(t%1==0)t>4294967295?(n=l.double,o.writeDoubleLE(t,0),r=8):t>65535?(n=l.uint32,o.writeUInt32LE(t,0),r=4):t>16?(n=l.uint16,o.writeUInt16LE(t,0),r=2):(n=l.uint8,o.writeUInt8(t,0),r=1);else{let e=!1;if(t<a[0]||t>a[1])e=!0;else{const i=String(t).split(".")[1];(0,s.default)(!!i),i.length>7&&(e=!0)}e?(n=l.double,o.writeDoubleLE(t,0),r=8):(n=l.float,o.writeFloatLE(t,0),r=4)}else{if("symbol"==typeof t)throw new Error("Unsupported type.");if(void 0===t)throw new Error("Unsupported type.");{let e="";try{e=JSON.stringify(t),n=l.json,o=Buffer.from(e),r=o.length}catch(e){throw new Error("Unsupported type.")}}}const u=Buffer.from(e),f=u.length;return Buffer.concat([Buffer.from(i.default.encode(n)),Buffer.from(i.default.encode(f)),Buffer.from(i.default.encode(r)),u,o.slice(0,r)])}constructor(){o(this,"_buffer",void 0),this._buffer=Buffer.allocUnsafe(0)}get buffer(){return this._buffer}add(e,t){this._buffer=Buffer.concat([this._buffer,h.addEntry(e,t)])}}t.BootBuffer=h})),at=h(c((function(e,t){t.__esModule=!0,t.EntryValueType=t.ValueType=t.BootBuffer=void 0,t.BootBuffer=ot.BootBuffer,t.ValueType=ot.ValueType,t.EntryValueType=ot.EntryValueType})));exports.SplashDBServer=class{constructor(e){u(this,"options",void 0),u(this,"authManager",void 0),u(this,"dbManager",void 0),u(this,"server",void 0),u(this,"start",()=>{const e=this.options.secure?t.createSecureServer({key:this.options.secureKey,cert:this.options.secureCert}):t.createServer();e.on("error",e=>console.error(e)),e.on("session",e=>{}),e.on("stream",async(e,t)=>{const i=t.authorization,s=t["x-splashdb-method"],r=t["x-splashdb-db"];if("GET"===t[":method"])return e.respond({":status":200}),void e.end("Splashdb");if("string"!=typeof s||"string"!=typeof r)return e.respond({":status":400}),void e.end("Bad Request");if(!await this.authManager.can(i,s,r))return e.respond({":status":403}),void e.end("Forbidden");const n=this.dbManager.getDB(r);if("iterator"===s){let t,i=!1,s=!1;e.on("data",async r=>{if(s)return;s=!0;const o={};for await(const e of at.BootBuffer.read("string"==typeof r?Buffer.from(r):r))o[e.key]=e.value;for(t=n.iterator(o);;){const s=await t.next();if(!i&&s.done)return i=!0,e.write(Buffer.alloc(0)),void e.end();if(!i&&!s.done){const t=new at.BootBuffer;t.add("key",s.value.key),t.add("value",s.value.value);const i=t.buffer.length,r=Buffer.concat([Buffer.from(F.encode(i)),t.buffer]);e.write(r)}}}),e.on("end",()=>{i||(i=!0,e.write(Buffer.alloc(0)),e.end())})}else{const t=[];e.on("data",e=>{"string"==typeof e?t.push((new TextEncoder).encode(e)):t.push(e)}),e.on("end",async()=>{const i=t.reduce((e,t)=>e+=t.byteLength,0),r=new Uint8Array(i);let o=0;for(const e of t)r.set(new Uint8Array(e),o),o=e.byteLength;const a={};for await(const e of at.BootBuffer.read(Buffer.from(r)))a[e.key]=e.value;if("get"===s){const t=await n.get(a.key);t?e.write(t):e.respond({":status":404})}else"put"===s?(await n.put(a.key,a.value),e.write(Buffer.alloc(0))):"del"===s&&(await n.del(a.key),e.write(Buffer.alloc(0)));e.end()})}}),e.listen(this.options.port),this.server=e}),this.options={secure:!1,port:8443,secureCert:"",secureKey:"",dbpath:"/data/db",adminPassword:i.randomBytes(40).toString("hex"),...e},this.dbManager=new nt(this.options),this.authManager=new f(this.options,this.dbManager),this.start()}async destroy(){await this.dbManager.destroy(),await new Promise(e=>{let t=!1;this.server.removeAllListeners(),this.server.close(()=>{t||(t=!0,this.server.unref(),e())})})}};
